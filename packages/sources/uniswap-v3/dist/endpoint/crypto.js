"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.execute = exports.inputParameters = exports.endpointResultPaths = exports.supportedEndpoints = void 0;
const tslib_1 = require("tslib");
const ea_bootstrap_1 = require("@chainlink/ea-bootstrap");
const config_1 = require("../config");
const ethers_1 = require("ethers");
const quoter_json_1 = tslib_1.__importDefault(require("../abis/quoter.json"));
const ERC20_json_1 = tslib_1.__importDefault(require("../abis/ERC20.json"));
const decimal_js_1 = require("decimal.js");
exports.supportedEndpoints = ['crypto'];
exports.endpointResultPaths = {
    crypto: 'rate',
};
exports.inputParameters = {
    from: ['base', 'from', 'coin'],
    fromAddress: false,
    fromDecimals: false,
    to: ['quote', 'to', 'market'],
    toAddress: false,
    toDecimals: false,
    amount: false,
    resultPath: false,
    feeTiers: false,
};
const execute = async (request, _, config) => {
    const validator = new ea_bootstrap_1.Validator(request, exports.inputParameters);
    if (validator.error)
        throw validator.error;
    const jobRunID = validator.validated.id;
    const { address: from, decimals: fromDecimals } = await getTokenDetails(validator, 'from', config);
    const { address: to, decimals: toDecimals } = await getTokenDetails(validator, 'to', config);
    const inputAmount = validator.validated.data.amount || 1;
    const amount = ethers_1.BigNumber.from(inputAmount).mul(ethers_1.BigNumber.from(10).pow(fromDecimals));
    const resultPath = validator.validated.data.resultPath;
    const feeTiers = validator.validated.data.feeTiers || config.feeTiers;
    const output = await getBestRate(from, to, amount, feeTiers, config);
    if (output.eq(0)) {
        throw new Error('Quoted output was zero. This pool or fee tier may not exist');
    }
    const outputAmount = new decimal_js_1.Decimal(output.toString()).div(new decimal_js_1.Decimal(10).pow(toDecimals));
    const rate = outputAmount.div(inputAmount);
    const data = {
        input: amount.toString(),
        inputToken: from,
        inputDecimals: fromDecimals,
        output: output.toString(),
        outputToken: to,
        outputDecimals: toDecimals,
        rate: rate.toNumber(),
    };
    const response = {
        status: 200,
        statusText: 'OK',
        headers: {},
        config: {},
        data: data,
    };
    const result = ea_bootstrap_1.Requester.validateResultNumber(response.data, [resultPath]);
    return ea_bootstrap_1.Requester.success(jobRunID, ea_bootstrap_1.Requester.withResult(response, result), config.verbose);
};
exports.execute = execute;
/**
 * getTokenDetails will find the address and number of decimal for a token.
 *
 * The order of operations is as follows:
 *  - address:
 *     1. Check if the address was provided in the request.
 *     2. If not, check the symbol in the request to see if we have pre-set the address for this symbol/network.
 *     3. If not, we assume the symbol param was actually the address.
 *  - decimals:
 *     1. Check if the number of decimals was provided in the request.
 *     2. Query the contract at the address found above to see how many decimals it's set to.
 * @param validator The validation class to use
 * @param direction Used to get the params in the request
 * - `{direction}` is the symbol of the token (to find pre-set token details)
 * - `{direction}Address` is the token address as set in the request
 * - `{direction}Decimals` is the number of decimals for the token as set in the request
 * @param config Configuration to extract token decimals from
 */
const getTokenDetails = async (validator, direction, config) => {
    const symbol = validator.overrideSymbol(config_1.NAME, validator.validated.data[direction]);
    const address = validator.validated.data[`${direction}Address`] ||
        validator.overrideToken(symbol, config.network) ||
        symbol;
    const decimals = validator.validated.data[`${direction}Decimals`] || (await getDecimals(address, config));
    return { address, decimals };
};
const getDecimals = async (address, config) => new ethers_1.ethers.Contract(address, ERC20_json_1.default, config.provider).decimals();
const getBestRate = async (from, to, amount, feeTiers, config) => {
    // pull abi from file
    const quoterContract = new ethers_1.ethers.Contract(config.uniswapQuoter, quoter_json_1.default, config.provider);
    // encode inputs for quoteExactInputSingle
    const sqrtPriceLimitX96 = 0;
    let bestPrice = ethers_1.BigNumber.from(0);
    // iterate over fee tiers
    for (const fee of feeTiers) {
        try {
            // execute non view function as a call
            const price = await quoterContract.callStatic.quoteExactInputSingle(from, to, fee, amount, sqrtPriceLimitX96);
            // update best price by largest amount out
            if (price > bestPrice) {
                bestPrice = price;
            }
        }
        catch (error) {
            console.error(`Failed with: ${error}`);
        }
    }
    return bestPrice;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3J5cHRvLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2VuZHBvaW50L2NyeXB0by50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsMERBQThEO0FBRTlELHNDQUF1RDtBQUN2RCxtQ0FBMEM7QUFDMUMsOEVBQTJDO0FBQzNDLDRFQUF5QztBQUN6QywyQ0FBb0M7QUFFdkIsUUFBQSxrQkFBa0IsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFBO0FBRS9CLFFBQUEsbUJBQW1CLEdBQUc7SUFDakMsTUFBTSxFQUFFLE1BQU07Q0FDZixDQUFBO0FBWVksUUFBQSxlQUFlLEdBQW9CO0lBQzlDLElBQUksRUFBRSxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDO0lBQzlCLFdBQVcsRUFBRSxLQUFLO0lBQ2xCLFlBQVksRUFBRSxLQUFLO0lBQ25CLEVBQUUsRUFBRSxDQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUUsUUFBUSxDQUFDO0lBQzdCLFNBQVMsRUFBRSxLQUFLO0lBQ2hCLFVBQVUsRUFBRSxLQUFLO0lBQ2pCLE1BQU0sRUFBRSxLQUFLO0lBQ2IsVUFBVSxFQUFFLEtBQUs7SUFDakIsUUFBUSxFQUFFLEtBQUs7Q0FDaEIsQ0FBQTtBQUVNLE1BQU0sT0FBTyxHQUE4QixLQUFLLEVBQUUsT0FBTyxFQUFFLENBQUMsRUFBRSxNQUFNLEVBQUUsRUFBRTtJQUM3RSxNQUFNLFNBQVMsR0FBRyxJQUFJLHdCQUFTLENBQUMsT0FBTyxFQUFFLHVCQUFlLENBQUMsQ0FBQTtJQUV6RCxJQUFJLFNBQVMsQ0FBQyxLQUFLO1FBQUUsTUFBTSxTQUFTLENBQUMsS0FBSyxDQUFBO0lBQzFDLE1BQU0sUUFBUSxHQUFHLFNBQVMsQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFBO0lBQ3ZDLE1BQU0sRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxZQUFZLEVBQUUsR0FBRyxNQUFNLGVBQWUsQ0FBQyxTQUFTLEVBQUUsTUFBTSxF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RjtRQUFDLE9BQU8sS0FBSyxFQUFFO1lBQ2QsT0FBTyxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsS0FBSyxFQUFFLENBQUMsQ0FBQTtTQUN2QztLQUNGO0lBRUQsT0FBTyxTQUFTLENBQUE7QUFDbEIsQ0FBQyxDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmVxdWVzdGVyLCBWYWxpZGF0b3IgfSBmcm9tICdAY2hhaW5saW5rL2VhLWJvb3RzdHJhcCdcbmltcG9ydCB7IEV4ZWN1dGVXaXRoQ29uZmlnLCBJbnB1dFBhcmFtZXRlcnMgfSBmcm9tICdAY2hhaW5saW5rL3R5cGVzJ1xuaW1wb3J0IHsgTkFNRSBhcyBBZGFwdGVyTmFtZSwgQ29uZmlnIH0gZnJvbSAnLi4vY29uZmlnJ1xuaW1wb3J0IHsgZXRoZXJzLCBCaWdOdW1iZXIgfSBmcm9tICdldGhlcnMnXG5pbXBvcnQgcXVvdGVyQUJJIGZyb20gJy4uL2FiaXMvcXVvdGVyLmpzb24nXG5pbXBvcnQgZXJjMjBBQkkgZnJvbSAnLi4vYWJpcy9FUkMyMC5qc29uJ1xuaW1wb3J0IHsgRGVjaW1hbCB9IGZyb20gJ2RlY2ltYWwuanMnXG5cbmV4cG9ydCBjb25zdCBzdXBwb3J0ZWRFbmRwb2ludHMgPSBbJ2NyeXB0byddXG5cbmV4cG9ydCBjb25zdCBlbmRwb2ludFJlc3VsdFBhdGhzID0ge1xuICBjcnlwdG86ICdyYXRlJyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZVNjaGVtYSB7XG4gIGlucHV0OiBzdHJpbmdcbiAgaW5wdXRUb2tlbjogc3RyaW5nXG4gIGlucHV0RGVjaW1hbHM6IG51bWJlclxuICBvdXRwdXQ6IHN0cmluZ1xuICBvdXRwdXRUb2tlbjogc3RyaW5nXG4gIG91dHB1dERlY2ltYWxzOiBudW1iZXJcbiAgcmF0ZTogbnVtYmVyXG59XG5cbmV4cG9ydCBjb25zdCBpbnB1dFBhcmFtZXRlcnM6IElucHV0UGFyYW1ldGVycyA9IHtcbiAgZnJvbTogWydiYXNlJywgJ2Zyb20nLCAnY29pbiddLFxuICBmcm9tQWRkcmVzczogZmFsc2UsXG4gIGZyb21EZWNpbWFsczogZmFsc2UsXG4gIHRvOiBbJ3F1b3RlJywgJ3RvJywgJ21hcmtldCddLFxuICB0b0FkZHJlc3M6IGZhbHNlLFxuICB0b0RlY2ltYWxzOiBmYWxzZSxcbiAgYW1vdW50OiBmYWxzZSxcbiAgcmVzdWx0UGF0aDogZmFsc2UsXG4gIGZlZVRpZXJzOiBmYWxzZSxcbn1cblxuZXhwb3J0IGNvbnN0IGV4ZWN1dGU6IEV4ZWN1dGVXaXRoQ29uZmlnPENvbmZpZz4gPSBhc3luYyAocmVxdWVzdCwgXywgY29uZmlnKSA9PiB7XG4gIGNvbnN0IHZhbGlkYXRvciA9IG5ldyBWYWxpZGF0b3IocmVxdWVzdCwgaW5wdXRQYXJhbWV0ZXJzKVxuXG4gIGlmICh2YWxpZGF0b3IuZXJyb3IpIHRocm93IHZhbGlkYXRvci5lcnJvclxuICBjb25zdCBqb2JSdW5JRCA9IHZhbGlkYXRvci52YWxpZGF0ZWQuaWRcbiAgY29uc3QgeyBhZGRyZXNzOiBmcm9tLCBkZWNpbWFsczogZnJvbURlY2ltYWxzIH0gPSBhd2FpdCBnZXRUb2tlbkRldGFpbHModmFsaWRhdG9yLCAnZnJvbScsIGNvbmZpZylcbiAgY29uc3QgeyBhZGRyZXNzOiB0bywgZGVjaW1hbHM6IHRvRGVjaW1hbHMgfSA9IGF3YWl0IGdldFRva2VuRGV0YWlscyh2YWxpZGF0b3IsICd0bycsIGNvbmZpZylcbiAgY29uc3QgaW5wdXRBbW91bnQgPSB2YWxpZGF0b3IudmFsaWRhdGVkLmRhdGEuYW1vdW50IHx8IDFcbiAgY29uc3QgYW1vdW50ID0gQmlnTnVtYmVyLmZyb20oaW5wdXRBbW91bnQpLm11bChCaWdOdW1iZXIuZnJvbSgxMCkucG93KGZyb21EZWNpbWFscykpXG4gIGNvbnN0IHJlc3VsdFBhdGggPSB2YWxpZGF0b3IudmFsaWRhdGVkLmRhdGEucmVzdWx0UGF0aFxuXG4gIGNvbnN0IGZlZVRpZXJzID0gdmFsaWRhdG9yLnZhbGlkYXRlZC5kYXRhLmZlZVRpZXJzIHx8IGNvbmZpZy5mZWVUaWVyc1xuICBjb25zdCBvdXRwdXQgPSBhd2FpdCBnZXRCZXN0UmF0ZShmcm9tLCB0bywgYW1vdW50LCBmZWVUaWVycywgY29uZmlnKVxuXG4gIGlmIChvdXRwdXQuZXEoMCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1b3RlZCBvdXRwdXQgd2FzIHplcm8uIFRoaXMgcG9vbCBvciBmZWUgdGllciBtYXkgbm90IGV4aXN0JylcbiAgfVxuXG4gIGNvbnN0IG91dHB1dEFtb3VudCA9IG5ldyBEZWNpbWFsKG91dHB1dC50b1N0cmluZygpKS5kaXYobmV3IERlY2ltYWwoMTApLnBvdyh0b0RlY2ltYWxzKSlcbiAgY29uc3QgcmF0ZSA9IG91dHB1dEFtb3VudC5kaXYoaW5wdXRBbW91bnQpXG5cbiAgY29uc3QgZGF0YTogUmVzcG9uc2VTY2hlbWEgPSB7XG4gICAgaW5wdXQ6IGFtb3VudC50b1N0cmluZygpLFxuICAgIGlucHV0VG9rZW46IGZyb20sXG4gICAgaW5wdXREZWNpbWFsczogZnJvbURlY2ltYWxzLFxuICAgIG91dHB1dDogb3V0cHV0LnRvU3RyaW5nKCksXG4gICAgb3V0cHV0VG9rZW46IHRvLFxuICAgIG91dHB1dERlY2ltYWxzOiB0b0RlY2ltYWxzLFxuICAgIHJhdGU6IHJhdGUudG9OdW1iZXIoKSxcbiAgfVxuXG4gIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgIHN0YXR1czogMjAwLFxuICAgIHN0YXR1c1RleHQ6ICdPSycsXG4gICAgaGVhZGVyczoge30sXG4gICAgY29uZmlnOiB7fSxcbiAgICBkYXRhOiBkYXRhLFxuICB9XG4gIGNvbnN0IHJlc3VsdCA9IFJlcXVlc3Rlci52YWxpZGF0ZVJlc3VsdE51bWJlcihyZXNwb25zZS5kYXRhLCBbcmVzdWx0UGF0aF0pXG5cbiAgcmV0dXJuIFJlcXVlc3Rlci5zdWNjZXNzKGpvYlJ1bklELCBSZXF1ZXN0ZXIud2l0aFJlc3VsdChyZXNwb25zZSwgcmVzdWx0KSwgY29uZmlnLnZlcmJvc2UpXG59XG5cbi8qKlxuICogZ2V0VG9rZW5EZXRhaWxzIHdpbGwgZmluZCB0aGUgYWRkcmVzcyBhbmQgbnVtYmVyIG9mIGRlY2ltYWwgZm9yIGEgdG9rZW4uXG4gKlxuICogVGhlIG9yZGVyIG9mIG9wZXJhdGlvbnMgaXMgYXMgZm9sbG93czpcbiAqICAtIGFkZHJlc3M6XG4gKiAgICAgMS4gQ2hlY2sgaWYgdGhlIGFkZHJlc3Mgd2FzIHByb3ZpZGVkIGluIHRoZSByZXF1ZXN0LlxuICogICAgIDIuIElmIG5vdCwgY2hlY2sgdGhlIHN5bWJvbCBpbiB0aGUgcmVxdWVzdCB0byBzZWUgaWYgd2UgaGF2ZSBwcmUtc2V0IHRoZSBhZGRyZXNzIGZvciB0aGlzIHN5bWJvbC9uZXR3b3JrLlxuICogICAgIDMuIElmIG5vdCwgd2UgYXNzdW1lIHRoZSBzeW1ib2wgcGFyYW0gd2FzIGFjdHVhbGx5IHRoZSBhZGRyZXNzLlxuICogIC0gZGVjaW1hbHM6XG4gKiAgICAgMS4gQ2hlY2sgaWYgdGhlIG51bWJlciBvZiBkZWNpbWFscyB3YXMgcHJvdmlkZWQgaW4gdGhlIHJlcXVlc3QuXG4gKiAgICAgMi4gUXVlcnkgdGhlIGNvbnRyYWN0IGF0IHRoZSBhZGRyZXNzIGZvdW5kIGFib3ZlIHRvIHNlZSBob3cgbWFueSBkZWNpbWFscyBpdCdzIHNldCB0by5cbiAqIEBwYXJhbSB2YWxpZGF0b3IgVGhlIHZhbGlkYXRpb24gY2xhc3MgdG8gdXNlXG4gKiBAcGFyYW0gZGlyZWN0aW9uIFVzZWQgdG8gZ2V0IHRoZSBwYXJhbXMgaW4gdGhlIHJlcXVlc3RcbiAqIC0gYHtkaXJlY3Rpb259YCBpcyB0aGUgc3ltYm9sIG9mIHRoZSB0b2tlbiAodG8gZmluZCBwcmUtc2V0IHRva2VuIGRldGFpbHMpXG4gKiAtIGB7ZGlyZWN0aW9ufUFkZHJlc3NgIGlzIHRoZSB0b2tlbiBhZGRyZXNzIGFzIHNldCBpbiB0aGUgcmVxdWVzdFxuICogLSBge2RpcmVjdGlvbn1EZWNpbWFsc2AgaXMgdGhlIG51bWJlciBvZiBkZWNpbWFscyBmb3IgdGhlIHRva2VuIGFzIHNldCBpbiB0aGUgcmVxdWVzdFxuICogQHBhcmFtIGNvbmZpZyBDb25maWd1cmF0aW9uIHRvIGV4dHJhY3QgdG9rZW4gZGVjaW1hbHMgZnJvbVxuICovXG5jb25zdCBnZXRUb2tlbkRldGFpbHMgPSBhc3luYyAoXG4gIHZhbGlkYXRvcjogVmFsaWRhdG9yLFxuICBkaXJlY3Rpb246IHN0cmluZyxcbiAgY29uZmlnOiBDb25maWcsXG4pOiBQcm9taXNlPHsgYWRkcmVzczogc3RyaW5nOyBkZWNpbWFsczogbnVtYmVyIH0+ID0+IHtcbiAgY29uc3Qgc3ltYm9sID0gdmFsaWRhdG9yLm92ZXJyaWRlU3ltYm9sKFxuICAgIEFkYXB0ZXJOYW1lLFxuICAgIHZhbGlkYXRvci52YWxpZGF0ZWQuZGF0YVtkaXJlY3Rpb25dLFxuICApIGFzIHN0cmluZ1xuICBjb25zdCBhZGRyZXNzID1cbiAgICB2YWxpZGF0b3IudmFsaWRhdGVkLmRhdGFbYCR7ZGlyZWN0aW9ufUFkZHJlc3NgXSB8fFxuICAgIHZhbGlkYXRvci5vdmVycmlkZVRva2VuKHN5bWJvbCwgY29uZmlnLm5ldHdvcmspIHx8XG4gICAgc3ltYm9sXG4gIGNvbnN0IGRlY2ltYWxzID1cbiAgICB2YWxpZGF0b3IudmFsaWRhdGVkLmRhdGFbYCR7ZGlyZWN0aW9ufURlY2ltYWxzYF0gfHwgKGF3YWl0IGdldERlY2ltYWxzKGFkZHJlc3MsIGNvbmZpZykpXG5cbiAgcmV0dXJuIHsgYWRkcmVzcywgZGVjaW1hbHMgfVxufVxuXG5jb25zdCBnZXREZWNpbWFscyA9IGFzeW5jIChhZGRyZXNzOiBzdHJpbmcsIGNvbmZpZzogQ29uZmlnKTogUHJvbWlzZTxudW1iZXI+ID0+XG4gIG5ldyBldGhlcnMuQ29udHJhY3QoYWRkcmVzcywgZXJjMjBBQkksIGNvbmZpZy5wcm92aWRlcikuZGVjaW1hbHMoKVxuXG5jb25zdCBnZXRCZXN0UmF0ZSA9IGFzeW5jIChcbiAgZnJvbTogc3RyaW5nLFxuICB0bzogc3RyaW5nLFxuICBhbW91bnQ6IEJpZ051bWJlcixcbiAgZmVlVGllcnM6IG51bWJlcltdLFxuICBjb25maWc6IENvbmZpZyxcbik6IFByb21pc2U8QmlnTnVtYmVyPiA9PiB7XG4gIC8vIHB1bGwgYWJpIGZyb20gZmlsZVxuICBjb25zdCBxdW90ZXJDb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoY29uZmlnLnVuaXN3YXBRdW90ZXIsIHF1b3RlckFCSSwgY29uZmlnLnByb3ZpZGVyKVxuXG4gIC8vIGVuY29kZSBpbnB1dHMgZm9yIHF1b3RlRXhhY3RJbnB1dFNpbmdsZVxuICBjb25zdCBzcXJ0UHJpY2VMaW1pdFg5NiA9IDBcbiAgbGV0IGJlc3RQcmljZSA9IEJpZ051bWJlci5mcm9tKDApXG5cbiAgLy8gaXRlcmF0ZSBvdmVyIGZlZSB0aWVyc1xuICBmb3IgKGNvbnN0IGZlZSBvZiBmZWVUaWVycykge1xuICAgIHRyeSB7XG4gICAgICAvLyBleGVjdXRlIG5vbiB2aWV3IGZ1bmN0aW9uIGFzIGEgY2FsbFxuICAgICAgY29uc3QgcHJpY2UgPSBhd2FpdCBxdW90ZXJDb250cmFjdC5jYWxsU3RhdGljLnF1b3RlRXhhY3RJbnB1dFNpbmdsZShcbiAgICAgICAgZnJvbSxcbiAgICAgICAgdG8sXG4gICAgICAgIGZlZSxcbiAgICAgICAgYW1vdW50LFxuICAgICAgICBzcXJ0UHJpY2VMaW1pdFg5NixcbiAgICAgIClcbiAgICAgIC8vIHVwZGF0ZSBiZXN0IHByaWNlIGJ5IGxhcmdlc3QgYW1vdW50IG91dFxuICAgICAgaWYgKHByaWNlID4gYmVzdFByaWNlKSB7XG4gICAgICAgIGJlc3RQcmljZSA9IHByaWNlXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB3aXRoOiAke2Vycm9yfWApXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJlc3RQcmljZVxufVxuIl19