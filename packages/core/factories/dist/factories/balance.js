"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.make = exports.inputParameters = void 0;
const tslib_1 = require("tslib");
const ea_bootstrap_1 = require("@chainlink/ea-bootstrap");
const object_path_1 = tslib_1.__importDefault(require("object-path"));
const DEFAULT_DATA_PATH = 'result';
const DEFAULT_CONFIRMATIONS = 6;
const WARNING_UNSUPPORTED_PARAMS = 'No Operation: this provider does not support';
const ERROR_MISSING_ADDRESS = 'No Operation: address param is missing';
const requireArray = (jobRunID, dataPath, data) => {
    const inputData = object_path_1.default.get(data, dataPath);
    // Check if input data is valid
    if (!inputData || !Array.isArray(inputData) || inputData.length === 0)
        throw new ea_bootstrap_1.AdapterError({
            jobRunID,
            message: `Input, at '${dataPath}' path, must be a non-empty array.`,
            statusCode: 400,
        });
    return inputData;
};
const toValidAccount = (jobRunID, account, config) => {
    // Is it possible to process?
    if (!account.address)
        throw new ea_bootstrap_1.AdapterError({
            jobRunID,
            message: ERROR_MISSING_ADDRESS,
            statusCode: 400,
        });
    // Defaults
    if (!account.chain)
        account.chain = 'mainnet';
    if (!account.coin)
        account.coin = 'btc';
    // Do we support processing?
    const supported = config.isSupported(account.coin, account.chain);
    if (!supported)
        return { ...account, warning: WARNING_UNSUPPORTED_PARAMS + ` ${account.chain} ${account.coin}` };
    // If warning, clear and continue to processing
    const { warning, ...accNoWarning } = account;
    return accNoWarning;
};
const toGetBalances = (getBalance) => (accounts, config) => {
    if (!getBalance)
        throw new Error('Get Balance function not supplied');
    return accounts.map((acc) => getBalance(acc, config));
};
exports.inputParameters = {
    dataPath: false,
    confirmations: false,
};
const make = (config) => async (input) => {
    const validator = new ea_bootstrap_1.Validator(input, exports.inputParameters);
    if (validator.error)
        throw validator.error;
    if (!config)
        throw new Error('No configuration supplied');
    if (!config.getBalance && !config.getBalances)
        throw new Error('Request handling logic not supplied');
    config.confirmations = validator.validated.confirmations || DEFAULT_CONFIRMATIONS;
    const jobRunID = validator.validated.id;
    const dataPath = validator.validated.data.dataPath || DEFAULT_DATA_PATH;
    const accounts = requireArray(jobRunID, dataPath, input.data).map((acc) => toValidAccount(jobRunID, acc, config));
    const accountsToProcess = accounts.filter((acc) => !acc.warning);
    const getBalances = config.getBalances || toGetBalances(config.getBalance);
    const key = (acc) => `${acc.coin}-${acc.chain}`;
    const groups = Array.from(ea_bootstrap_1.util.groupBy(accountsToProcess, key).values());
    const requests = groups.flatMap((group) => getBalances(group, config));
    const responses = await Promise.all(requests);
    const responseLookup = Object.fromEntries(responses.flatMap((r) => r.result).map((a) => [`${a.address}-${a.coin}-${a.chain}`, a]));
    const data = {
        responses: responses.map((r) => r.payload),
        result: accounts.map((a) => responseLookup[`${a.address}-${a.coin}-${a.chain}`] || a),
    };
    if (!config.verbose)
        delete data.responses;
    return { jobRunID, statusCode: 200, data, result: data.result };
};
exports.make = make;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFsYW5jZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9mYWN0b3JpZXMvYmFsYW5jZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsMERBQXVFO0FBU3ZFLHNFQUFvQztBQUVwQyxNQUFNLGlCQUFpQixHQUFHLFFBQVEsQ0FBQTtBQUNsQyxNQUFNLHFCQUFxQixHQUFHLENBQUMsQ0FBQTtBQUUvQixNQUFNLDBCQUEwQixHQUFHLDhDQUE4QyxDQUFBO0FBQ2pGLE1BQU0scUJBQXFCLEdBQUcsd0NBQXdDLENBQUE7QUFjdEUsTUFBTSxZQUFZLEdBQUcsQ0FBQyxRQUFnQixFQUFFLFFBQWdCLEVBQUUsSUFBUyxFQUFFLEVBQUU7SUFDckUsTUFBTSxTQUFTLEdBQWMscUJBQVUsQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFBO0lBRTNELCtCQUErQjtJQUMvQixJQUFJLENBQUMsU0FBUyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsSUFBSSxTQUFTLENBQUMsTUFBTSxLQUFLLENBQUM7UUFDbkUsTUFBTSxJQUFJLDJCQUFZLENBQUM7WUFDckIsUUFBUTtZQUNSLE9BQU8sRUFBRSxjQUFjLFFBQVEsb0NBQW9DO1lBQ25FLFVBQVUsRUFBRSxHQUFHO1NBQ2hCLENBQUMsQ0FBQTtJQUVKLE9BQU8sU0FBUyxDQUFBO0FBQ2xCLENBQUMsQ0FBQTtBQUVELE1BQU0sY0FBYyxHQUFHLENBQUMsUUFBZ0IsRUFBRSxPQUFnQixFQUFFLE1BQXFCLEVBQVcsRUFBRTtJQUM1Riw2QkFBNkI7SUFDN0IsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPO1FBQ2xCLE1BQU0sSUFBSSwyQkFBWSxDQUFDO1lBQ3JCLFFBQVE7WUFDUixPQUFPLEVBQUUscUJBQXFCO1lBQzlCLFVBQVUsRUFBRSxHQUFHO1NBQ2hCLENBQUMsQ0FBQTtJQUVKLFdBQVc7SUFDWCxJQUFJLENBQUMsT0FBTyxDQUFDLEtB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QUFqQ1ksUUFBQSxJQUFJLFFBaUNoQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFkYXB0ZXJFcnJvciwgdXRpbCwgVmFsaWRhdG9yIH0gZnJvbSAnQGNoYWlubGluay9lYS1ib290c3RyYXAnXG5pbXBvcnQge1xuICBBY2NvdW50LFxuICBDb25maWcsXG4gIERhdGFSZXNwb25zZSxcbiAgRXhlY3V0ZUZhY3RvcnksXG4gIFNlcXVlbmNlUmVzcG9uc2VEYXRhLFxuICBJbnB1dFBhcmFtZXRlcnMsXG59IGZyb20gJ0BjaGFpbmxpbmsvdHlwZXMnXG5pbXBvcnQgb2JqZWN0UGF0aCBmcm9tICdvYmplY3QtcGF0aCdcblxuY29uc3QgREVGQVVMVF9EQVRBX1BBVEggPSAncmVzdWx0J1xuY29uc3QgREVGQVVMVF9DT05GSVJNQVRJT05TID0gNlxuXG5jb25zdCBXQVJOSU5HX1VOU1VQUE9SVEVEX1BBUkFNUyA9ICdObyBPcGVyYXRpb246IHRoaXMgcHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCdcbmNvbnN0IEVSUk9SX01JU1NJTkdfQUREUkVTUyA9ICdObyBPcGVyYXRpb246IGFkZHJlc3MgcGFyYW0gaXMgbWlzc2luZydcblxuZXhwb3J0IHR5cGUgSXNTdXBwb3J0ZWQgPSAoY29pbjogc3RyaW5nLCBjaGFpbjogc3RyaW5nKSA9PiBib29sZWFuXG5leHBvcnQgdHlwZSBCYWxhbmNlc1Jlc3BvbnNlID0gRGF0YVJlc3BvbnNlPEFjY291bnRbXSwgYW55PlxuZXhwb3J0IHR5cGUgR2V0QmFsYW5jZSA9IChhY2NvdW50OiBBY2NvdW50LCBjb25maWc6IEJhbGFuY2VDb25maWcpID0+IFByb21pc2U8QmFsYW5jZXNSZXNwb25zZT5cbmV4cG9ydCB0eXBlIEdldEJhbGFuY2VzID0gKGFjY291bnRzOiBBY2NvdW50W10sIGNvbmZpZzogQmFsYW5jZUNvbmZpZykgPT4gUHJvbWlzZTxCYWxhbmNlc1Jlc3BvbnNlPlxuXG5leHBvcnQgdHlwZSBCYWxhbmNlQ29uZmlnID0gQ29uZmlnICYge1xuICBjb25maXJtYXRpb25zPzogbnVtYmVyXG4gIGlzU3VwcG9ydGVkOiBJc1N1cHBvcnRlZFxuICBnZXRCYWxhbmNlPzogR2V0QmFsYW5jZVxuICBnZXRCYWxhbmNlcz86IEdldEJhbGFuY2VzXG59XG5cbmNvbnN0IHJlcXVpcmVBcnJheSA9IChqb2JSdW5JRDogc3RyaW5nLCBkYXRhUGF0aDogc3RyaW5nLCBkYXRhOiBhbnkpID0+IHtcbiAgY29uc3QgaW5wdXREYXRhID0gPEFjY291bnRbXT5vYmplY3RQYXRoLmdldChkYXRhLCBkYXRhUGF0aClcblxuICAvLyBDaGVjayBpZiBpbnB1dCBkYXRhIGlzIHZhbGlkXG4gIGlmICghaW5wdXREYXRhIHx8ICFBcnJheS5pc0FycmF5KGlucHV0RGF0YSkgfHwgaW5wdXREYXRhLmxlbmd0aCA9PT0gMClcbiAgICB0aHJvdyBuZXcgQWRhcHRlckVycm9yKHtcbiAgICAgIGpvYlJ1bklELFxuICAgICAgbWVzc2FnZTogYElucHV0LCBhdCAnJHtkYXRhUGF0aH0nIHBhdGgsIG11c3QgYmUgYSBub24tZW1wdHkgYXJyYXkuYCxcbiAgICAgIHN0YXR1c0NvZGU6IDQwMCxcbiAgICB9KVxuXG4gIHJldHVybiBpbnB1dERhdGFcbn1cblxuY29uc3QgdG9WYWxpZEFjY291bnQgPSAoam9iUnVuSUQ6IHN0cmluZywgYWNjb3VudDogQWNjb3VudCwgY29uZmlnOiBCYWxhbmNlQ29uZmlnKTogQWNjb3VudCA9PiB7XG4gIC8vIElzIGl0IHBvc3NpYmxlIHRvIHByb2Nlc3M/XG4gIGlmICghYWNjb3VudC5hZGRyZXNzKVxuICAgIHRocm93IG5ldyBBZGFwdGVyRXJyb3Ioe1xuICAgICAgam9iUnVuSUQsXG4gICAgICBtZXNzYWdlOiBFUlJPUl9NSVNTSU5HX0FERFJFU1MsXG4gICAgICBzdGF0dXNDb2RlOiA0MDAsXG4gICAgfSlcblxuICAvLyBEZWZhdWx0c1xuICBpZiAoIWFjY291bnQuY2hhaW4pIGFjY291bnQuY2hhaW4gPSAnbWFpbm5ldCdcbiAgaWYgKCFhY2NvdW50LmNvaW4pIGFjY291bnQuY29pbiA9ICdidGMnXG5cbiAgLy8gRG8gd2Ugc3VwcG9ydCBwcm9jZXNzaW5nP1xuICBjb25zdCBzdXBwb3J0ZWQgPSBjb25maWcuaXNTdXBwb3J0ZWQoYWNjb3VudC5jb2luLCBhY2NvdW50LmNoYWluKVxuICBpZiAoIXN1cHBvcnRlZClcbiAgICByZXR1cm4geyAuLi5hY2NvdW50LCB3YXJuaW5nOiBXQVJOSU5HX1VOU1VQUE9SVEVEX1BBUkFNUyArIGAgJHthY2NvdW50LmNoYWlufSAke2FjY291bnQuY29pbn1gIH1cblxuICAvLyBJZiB3YXJuaW5nLCBjbGVhciBhbmQgY29udGludWUgdG8gcHJvY2Vzc2luZ1xuICBjb25zdCB7IHdhcm5pbmcsIC4uLmFjY05vV2FybmluZyB9ID0gYWNjb3VudFxuICByZXR1cm4gYWNjTm9XYXJuaW5nXG59XG5cbmNvbnN0IHRvR2V0QmFsYW5jZXMgPSAoZ2V0QmFsYW5jZT86IEdldEJhbGFuY2UpID0+IChhY2NvdW50czogQWNjb3VudFtdLCBjb25maWc6IEJhbGFuY2VDb25maWcpID0+IHtcbiAgaWYgKCFnZXRCYWxhbmNlKSB0aHJvdyBuZXcgRXJyb3IoJ0dldCBCYWxhbmNlIGZ1bmN0aW9uIG5vdCBzdXBwbGllZCcpXG4gIHJldHVybiBhY2NvdW50cy5tYXAoKGFjYykgPT4gZ2V0QmFsYW5jZShhY2MsIGNvbmZpZykpXG59XG5cbmV4cG9ydCBjb25zdCBpbnB1dFBhcmFtZXRlcnM6IElucHV0UGFyYW1ldGVycyA9IHtcbiAgZGF0YVBhdGg6IGZhbHNlLFxuICBjb25maXJtYXRpb25zOiBmYWxzZSxcbn1cblxuZXhwb3J0IGNvbnN0IG1ha2U6IEV4ZWN1dGVGYWN0b3J5PEJhbGFuY2VDb25maWc+ID0gKGNvbmZpZykgPT4gYXN5bmMgKGlucHV0KSA9PiB7XG4gIGNvbnN0IHZhbGlkYXRvciA9IG5ldyBWYWxpZGF0b3IoaW5wdXQsIGlucHV0UGFyYW1ldGVycylcbiAgaWYgKHZhbGlkYXRvci5lcnJvcikgdGhyb3cgdmFsaWRhdG9yLmVycm9yXG4gIGlmICghY29uZmlnKSB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvbmZpZ3VyYXRpb24gc3VwcGxpZWQnKVxuICBpZiAoIWNvbmZpZy5nZXRCYWxhbmNlICYmICFjb25maWcuZ2V0QmFsYW5jZXMpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1ZXN0IGhhbmRsaW5nIGxvZ2ljIG5vdCBzdXBwbGllZCcpXG4gIGNvbmZpZy5jb25maXJtYXRpb25zID0gdmFsaWRhdG9yLnZhbGlkYXRlZC5jb25maXJtYXRpb25zIHx8IERFRkFVTFRfQ09ORklSTUFUSU9OU1xuICBjb25zdCBqb2JSdW5JRCA9IHZhbGlkYXRvci52YWxpZGF0ZWQuaWRcbiAgY29uc3QgZGF0YVBhdGggPSB2YWxpZGF0b3IudmFsaWRhdGVkLmRhdGEuZGF0YVBhdGggfHwgREVGQVVMVF9EQVRBX1BBVEhcblxuICBjb25zdCBhY2NvdW50cyA9IHJlcXVpcmVBcnJheShqb2JSdW5JRCwgZGF0YVBhdGgsIGlucHV0LmRhdGEpLm1hcCgoYWNjKSA9PlxuICAgIHRvVmFsaWRBY2NvdW50KGpvYlJ1bklELCBhY2MsIGNvbmZpZyksXG4gIClcbiAgY29uc3QgYWNjb3VudHNUb1Byb2Nlc3MgPSBhY2NvdW50cy5maWx0ZXIoKGFjYykgPT4gIWFjYy53YXJuaW5nKVxuXG4gIGNvbnN0IGdldEJhbGFuY2VzID0gY29uZmlnLmdldEJhbGFuY2VzIHx8IHRvR2V0QmFsYW5jZXMoY29uZmlnLmdldEJhbGFuY2UpXG5cbiAgY29uc3Qga2V5ID0gKGFjYzogQWNjb3VudCkgPT4gYCR7YWNjLmNvaW59LSR7YWNjLmNoYWlufWBcbiAgY29uc3QgZ3JvdXBzID0gQXJyYXkuZnJvbSh1dGlsLmdyb3VwQnkoYWNjb3VudHNUb1Byb2Nlc3MsIGtleSkudmFsdWVzKCkpXG4gIGNvbnN0IHJlcXVlc3RzID0gZ3JvdXBzLmZsYXRNYXAoKGdyb3VwKSA9PiBnZXRCYWxhbmNlcyhncm91cCBhcyBBY2NvdW50W10sIGNvbmZpZykpXG4gIGNvbnN0IHJlc3BvbnNlcyA9IGF3YWl0IFByb21pc2UuYWxsKHJlcXVlc3RzKVxuICBjb25zdCByZXNwb25zZUxvb2t1cCA9IE9iamVjdC5mcm9tRW50cmllczxBY2NvdW50PihcbiAgICByZXNwb25zZXMuZmxhdE1hcCgocikgPT4gci5yZXN1bHQpLm1hcCgoYSkgPT4gW2Ake2EuYWRkcmVzc30tJHthLmNvaW59LSR7YS5jaGFpbn1gLCBhXSksXG4gIClcblxuICBjb25zdCBkYXRhOiBTZXF1ZW5jZVJlc3BvbnNlRGF0YTxBY2NvdW50PiA9IHtcbiAgICByZXNwb25zZXM6IHJlc3BvbnNlcy5tYXAoKHI6IGFueSkgPT4gci5wYXlsb2FkKSxcbiAgICByZXN1bHQ6IGFjY291bnRzLm1hcCgoYSkgPT4gcmVzcG9uc2VMb29rdXBbYCR7YS5hZGRyZXNzfS0ke2EuY29pbn0tJHthLmNoYWlufWBdIHx8IGEpLFxuICB9XG5cbiAgaWYgKCFjb25maWcudmVyYm9zZSkgZGVsZXRlIGRhdGEucmVzcG9uc2VzXG5cbiAgcmV0dXJuIHsgam9iUnVuSUQsIHN0YXR1c0NvZGU6IDIwMCwgZGF0YSwgcmVzdWx0OiBkYXRhLnJlc3VsdCB9XG59XG4iXX0=