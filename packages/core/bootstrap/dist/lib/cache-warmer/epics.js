"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.epicMiddleware = exports.rootEpic = exports.warmupUnsubscriber = exports.warmupRequestHandler = exports.warmupSubscriber = exports.executeHandler = void 0;
const tslib_1 = require("tslib");
const lodash_1 = require("lodash");
const redux_observable_1 = require("redux-observable");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const actions_1 = require("./actions");
const config_1 = require("./config");
const util_1 = require("./util");
const ttl_1 = require("../cache/ttl");
const metrics = tslib_1.__importStar(require("./metrics"));
const util_2 = require("../metrics/util");
const executeHandler = (action$, state$) => {
    const warmupExecute$ = action$.pipe(operators_1.filter(actions_1.warmupExecute.match));
    const [batchExecute$, execute$] = rxjs_1.partition(warmupExecute$, (val) => !!val.payload.result?.debug?.batchablePropertyPath);
    const subscribeBatch$ = batchExecute$.pipe(operators_1.withLatestFrom(state$), operators_1.mergeMap(([{ payload }, state]) => {
        const actionsToDispatch = [];
        const batchablePropertyPath = payload.result?.debug?.batchablePropertyPath;
        // We want the key to be consistent. So we omit batchable paths.
        // Otherwise it would change on every new child
        const batchWarmerSubscriptionKey = util_1.getSubscriptionKey(lodash_1.omit(payload, batchablePropertyPath?.map(({ name }) => `data.${name}`)));
        const existingBatchWarmer = state.cacheWarmer.subscriptions[batchWarmerSubscriptionKey];
        // Start placeholder subscriptions for children
        const childLastSeenById = {};
        // If result was from a batch request
        if (payload.result?.data?.results) {
            const members = [];
            for (const [request] of Object.values(payload.result.data.results)) {
                const warmupSubscribedPayloadChild = {
                    ...payload,
                    ...request,
                    parent: batchWarmerSubscriptionKey,
                    batchablePropertyPath,
                };
                const childKey = util_1.getSubscriptionKey(warmupSubscribedPayloadChild);
                childLastSeenById[childKey] = Date.now();
                members.push(warmupSubscribedPayloadChild);
            }
            actionsToDispatch.push(actions_1.warmupSubscribedMultiple({ members }));
        }
        else {
            const warmupSubscribedPayloadChild = {
                ...payload,
                parent: batchWarmerSubscriptionKey,
                batchablePropertyPath,
            };
            const childKey = util_1.getSubscriptionKey(warmupSubscribedPayloadChild);
            childLastSeenById[childKey] = Date.now();
            actionsToDispatch.push(actions_1.warmupSubscribed(warmupSubscribedPayloadChild));
        }
        // If batch warmer already exists join it by adding childLastSeenById to request data
        if (existingBatchWarmer && batchablePropertyPath) {
            actionsToDispatch.push(actions_1.warmupJoinGroup({
                parent: batchWarmerSubscriptionKey,
                childLastSeenById: childLastSeenById,
                batchablePropertyPath,
            }));
        }
        // If batch warmer does not exist, start it
        else {
            // If incoming batchable request parameters aren't an array, transform into one
            let batchWarmerData = {
                ...payload.data,
                resultPath: undefined,
            };
            for (const { name } of batchablePropertyPath || []) {
                if (!Array.isArray(batchWarmerData[name]))
                    batchWarmerData = {
                        ...batchWarmerData,
                        [name]: [batchWarmerData[name]],
                    };
            }
            actionsToDispatch.push(actions_1.warmupSubscribed({
                ...payload,
                data: batchWarmerData,
                key: batchWarmerSubscriptionKey,
                childLastSeenById,
                batchablePropertyPath,
            }));
        }
        return rxjs_1.from(actionsToDispatch);
    }));
    const subscribeIndividual$ = execute$.pipe(operators_1.map(({ payload }) => actions_1.warmupSubscribed(payload)));
    return rxjs_1.merge(subscribeBatch$, subscribeIndividual$);
};
exports.executeHandler = executeHandler;
const warmupSubscriber = (action$, state$, { config }) => action$.pipe(operators_1.filter(actions_1.warmupSubscribed.match), operators_1.map(({ payload }) => ({
    payload,
    key: payload.key || util_1.getSubscriptionKey(payload),
})), operators_1.withLatestFrom(state$), 
// check if the subscription already exists, then noop
operators_1.filter(([{ payload, key }, state]) => {
    // if a child, register, but don't warm
    if (payload.parent)
        return false;
    // if subscription does not exist, then continue
    // this check doesnt work because state is already set!
    return !state.cacheWarmer.subscriptions[key]?.isDuplicate;
}), operators_1.tap(([{ payload }]) => {
    const labels = {
        isBatched: String(!!payload.childLastSeenById),
    };
    metrics.cache_warmer_count.labels(labels).inc();
}), 
// on a subscribe action being dispatched, spin up a long lived interval if one doesnt exist yet
operators_1.mergeMap(([{ payload, key }]) => {
    // Interval should be set to the warmup interval if configured,
    // otherwise use the TTL from the request.
    const interval = config.warmupInterval || ttl_1.getTTL(payload);
    const offset = Math.min(interval, 1000);
    const pollInterval = interval - offset;
    return rxjs_1.timer(pollInterval, pollInterval).pipe(operators_1.mapTo(actions_1.warmupRequested({ key })), 
    // unsubscribe our warmup algo when a matching unsubscribe comes in
    operators_1.takeUntil(action$.pipe(operators_1.filter(actions_1.warmupUnsubscribed.match || actions_1.warmupStopped.match), operators_1.filter((a) => a.payload.key === key), operators_1.withLatestFrom(state$), operators_1.tap(([{ payload }, state]) => {
        const labels = {
            isBatched: String(!!state.cacheWarmer.subscriptions[payload.key]?.childLastSeenById),
        };
        metrics.cache_warmer_count.labels(labels).dec();
    }))));
}));
exports.warmupSubscriber = warmupSubscriber;
/**
 * Handle warmup response request events
 */
const warmupRequestHandler = (action$, state$) => action$.pipe(
// this pipeline will execute when we have a request to warm up an adapter
operators_1.filter(actions_1.warmupRequested.match), 
// fetch our required state to make a request to warm up an adapter
operators_1.withLatestFrom(state$), operators_1.map(([action, state]) => {
    return {
        requestData: state.cacheWarmer.subscriptions[action.payload.key],
        key: action.payload.key,
        subscriptions: state.cacheWarmer.subscriptions,
    };
}), operators_1.filter(({ requestData }) => !!requestData), 
// make the request
operators_1.mergeMap(({ requestData, key }) => rxjs_1.from(requestData.batchablePropertyPath
    ? (async () => {
        const batches = util_1.splitIntoBatches(requestData);
        const requests = [];
        for (const batch of Object.values(batches)) {
            const data = {
                ...requestData.origin,
                ...batch,
            };
            requests.push(requestData.executeFn({
                id: requestData.childLastSeenById ? config_1.WARMUP_BATCH_REQUEST_ID : config_1.WARMUP_REQUEST_ID,
                data,
                debug: { warmer: true },
            }));
        }
        const responses = await Promise.all(requests);
        let result = null;
        for (const resp of responses) {
            result = util_1.concatenateBatchResults(result, resp);
        }
        return result;
    })()
    : requestData.executeFn({
        id: requestData.childLastSeenById ? config_1.WARMUP_BATCH_REQUEST_ID : config_1.WARMUP_REQUEST_ID,
        data: { ...requestData.origin },
        debug: { warmer: true },
    })).pipe(operators_1.mapTo(actions_1.warmupFulfilled({ key })), operators_1.catchError((error) => rxjs_1.of(actions_1.warmupFailed({
    feedLabel: util_2.getFeedId({
        id: requestData.childLastSeenById ? config_1.WARMUP_BATCH_REQUEST_ID : config_1.WARMUP_REQUEST_ID,
        data: requestData?.origin,
    }),
    error: error,
    key,
}))))));
exports.warmupRequestHandler = warmupRequestHandler;
// we can combine this into one of the above epics if we have performance issues later on
const warmupUnsubscriber = (action$, state$, { config }) => {
    const unsubscribeOnFailure$ = action$.pipe(operators_1.filter(actions_1.warmupFailed.match), operators_1.withLatestFrom(state$), operators_1.filter(([{ payload }, state]) => (state.cacheWarmer.warmups[payload.key]?.errorCount ?? 0 >= config.unhealthyThreshold) &&
        config.unhealthyThreshold !== -1), operators_1.map(([{ payload }]) => actions_1.warmupUnsubscribed({ key: payload.key, reason: `Errored: ${payload.error.message}` })));
    // emits whenever a subscription event comes in,
    // used as a helper stream for the timeout limit stream
    const keyedSubscription$ = action$.pipe(operators_1.filter(actions_1.warmupSubscribed.match), operators_1.map(({ payload }) => ({ payload, key: util_1.getSubscriptionKey(payload) })));
    const unsubscribeOnTimeout$ = keyedSubscription$.pipe(
    // when a subscription comes in
    operators_1.mergeMap(({ key }) => {
        // we look for matching subscriptions of the same type
        // which deactivates the current timer
        const reset$ = keyedSubscription$.pipe(operators_1.filter(({ key: keyB }) => key === keyB), operators_1.take(1), operators_1.mapTo(actions_1.warmupSubscriptionTimeoutReset({ key })));
        // start the current unsubscription timer
        const timeout$ = rxjs_1.of(actions_1.warmupUnsubscribed({ key, reason: 'Timeout' })).pipe(operators_1.delay(config.subscriptionTTL));
        // if a re-subscription comes in before timeout emits, then we emit nothing
        // else we unsubscribe from the current subscription
        return rxjs_1.race(reset$, timeout$);
    }));
    const stopOnBatch$ = keyedSubscription$.pipe(
    // when a subscription comes in, if it has children
    operators_1.filter(({ payload }) => !!payload?.childLastSeenById), operators_1.mergeMap(({ payload }) => [
        actions_1.warmupStopped({ keys: Object.keys(payload?.childLastSeenById || {}) }),
    ]));
    const unsubscribeOnBatchEmpty$ = action$.pipe(operators_1.filter(actions_1.warmupLeaveGroup.match), operators_1.withLatestFrom(state$), operators_1.filter(([{ payload }, state]) => {
        for (const { name } of payload.batchablePropertyPath) {
            if (state.cacheWarmer.subscriptions[payload.parent].origin[name].length === 0)
                return true;
        }
        return false;
    }), operators_1.map(([{ payload }]) => actions_1.warmupUnsubscribed({ key: payload.parent, reason: 'Empty Batch Warmer request data' })));
    return rxjs_1.merge(unsubscribeOnFailure$, unsubscribeOnTimeout$, stopOnBatch$, unsubscribeOnBatchEmpty$);
};
exports.warmupUnsubscriber = warmupUnsubscriber;
exports.rootEpic = redux_observable_1.combineEpics(exports.executeHandler, exports.warmupSubscriber, exports.warmupUnsubscriber, exports.warmupRequestHandler);
exports.epicMiddleware = redux_observable_1.createEpicMiddleware({
    dependencies: { config: config_1.get() },
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXBpY3MuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL2NhY2hlLXdhcm1lci9lcGljcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQ0EsbUNBQTZCO0FBRTdCLHVEQUEyRTtBQUMzRSwrQkFBOEQ7QUFDOUQsOENBV3VCO0FBRXZCLHVDQVlrQjtBQUNsQixxQ0FBa0Y7QUFDbEYsaUNBQXNGO0FBQ3RGLHNDQUFxQztBQUNyQywyREFBb0M7QUFDcEMsMENBQTJDO0FBTXBDLE1BQU0sY0FBYyxHQUE0RCxDQUNyRixPQUFPLEVBQ1AsTUFBTSxFQUNOLEVBQUU7SUFDRixNQUFNLGNBQWMsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLGtCQUFNLENBQUMsdUJBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFBO0lBQ2hFLE1BQU0sQ0FBQyxhQUFhLEVBQUUsUUFBUSxDQUFDLEdBQUcsZ0JBQVMsQ0FDekMsY0FBYyxFQUNkLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsS0FBSyxFQUFFLHFCQUFxQixDQUM1RCxDQUFBO0lBRUQsTUFBTSxlQUFlLEdBQUcsYUFBYSxDQUFDLElBQUksQ0FDeEMsMEJBQWMsQ0FBQyxNQUFNLENBQUMsRUFDdEIsb0JBQVEsQ0FBQyxDQUFDLENBQUMsRUFBRSxPQUFPLEVBQUUsRUFBRSxLQUFLLENBQUMsRUFBRSxFQUFFO1FBQ2hDLE1BQU0saUJBQWlCLEdBQWdCLEVBQUUsQ0FBQTtRQUV6QyxNQUFNLHFCQUFxQixHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUUsS0FBSyxFQUFFLHFCQUFxQixDQUFBO1FBRTFFLGdFQUFnRTtRQUNoRSwrQ0FBK0M7UUFDL0MsTUFBTSwwQkFBMEIsR0FBRyx5QkFBa0IsQ0FDbkQsYUFBSSxDQUNGLE9BQU8sRUFDUCxxQkFBcUIsRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxF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ZXN0IH0gZnJvbSAnQGNoYWlubGluay90eXBlcydcbmltcG9ydCB7IG9taXQgfSBmcm9tICdsb2Rhc2gnXG5pbXBvcnQgeyBBbnlBY3Rpb24gfSBmcm9tICdyZWR1eCdcbmltcG9ydCB7IGNvbWJpbmVFcGljcywgY3JlYXRlRXBpY01pZGRsZXdhcmUsIEVwaWMgfSBmcm9tICdyZWR1eC1vYnNlcnZhYmxlJ1xuaW1wb3J0IHsgZnJvbSwgbWVyZ2UsIG9mLCBwYXJ0aXRpb24sIHJhY2UsIHRpbWVyIH0gZnJvbSAncnhqcydcbmltcG9ydCB7XG4gIGNhdGNoRXJyb3IsXG4gIGRlbGF5LFxuICBmaWx0ZXIsXG4gIG1hcCxcbiAgbWFwVG8sXG4gIG1lcmdlTWFwLFxuICB0YXAsXG4gIHRha2UsXG4gIHRha2VVbnRpbCxcbiAgd2l0aExhdGVzdEZyb20sXG59IGZyb20gJ3J4anMvb3BlcmF0b3JzJ1xuaW1wb3J0IHsgUm9vdFN0YXRlIH0gZnJvbSAnLi4vLi4nXG5pbXBvcnQge1xuICB3YXJtdXBFeGVjdXRlLFxuICB3YXJtdXBGYWlsZWQsXG4gIHdhcm11cEZ1bGZpbGxlZCxcbiAgd2FybXVwSm9pbkdyb3VwLFxuICB3YXJtdXBMZWF2ZUdyb3VwLFxuICB3YXJtdXBSZXF1ZXN0ZWQsXG4gIHdhcm11cFN0b3BwZWQsXG4gIHdhcm11cFN1YnNjcmliZWQsXG4gIHdhcm11cFN1YnNjcmliZWRNdWx0aXBsZSxcbiAgd2FybXVwU3Vic2NyaXB0aW9uVGltZW91dFJlc2V0LFxuICB3YXJtdXBVbnN1YnNjcmliZWQsXG59IGZyb20gJy4vYWN0aW9ucydcbmltcG9ydCB7IENvbmZpZywgZ2V0LCBXQVJNVVBfUkVRVUVTVF9JRCwgV0FSTVVQX0JBVENIX1JFUVVFU1RfSUQgfSBmcm9tICcuL2NvbmZpZydcbmltcG9ydCB7IGNvbmNhdGVuYXRlQmF0Y2hSZXN1bHRzLCBnZXRTdWJzY3JpcHRpb25LZXksIHNwbGl0SW50b0JhdGNoZXMgfSBmcm9tICcuL3V0aWwnXG5pbXBvcnQgeyBnZXRUVEwgfSBmcm9tICcuLi9jYWNoZS90dGwnXG5pbXBvcnQgKiBhcyBtZXRyaWNzIGZyb20gJy4vbWV0cmljcydcbmltcG9ydCB7IGdldEZlZWRJZCB9IGZyb20gJy4uL21ldHJpY3MvdXRpbCdcblxuZXhwb3J0IGludGVyZmFjZSBFcGljRGVwZW5kZW5jaWVzIHtcbiAgY29uZmlnOiBDb25maWdcbn1cblxuZXhwb3J0IGNvbnN0IGV4ZWN1dGVIYW5kbGVyOiBFcGljPEFueUFjdGlvbiwgQW55QWN0aW9uLCBSb290U3RhdGUsIEVwaWNEZXBlbmRlbmNpZXM+ID0gKFxuICBhY3Rpb24kLFxuICBzdGF0ZSQsXG4pID0+IHtcbiAgY29uc3Qgd2FybXVwRXhlY3V0ZSQgPSBhY3Rpb24kLnBpcGUoZmlsdGVyKHdhcm11cEV4ZWN1dGUubWF0Y2gpKVxuICBjb25zdCBbYmF0Y2hFeGVjdXRlJCwgZXhlY3V0ZSRdID0gcGFydGl0aW9uKFxuICAgIHdhcm11cEV4ZWN1dGUkLFxuICAgICh2YWwpID0+ICEhdmFsLnBheWxvYWQucmVzdWx0Py5kZWJ1Zz8uYmF0Y2hhYmxlUHJvcGVydHlQYXRoLFxuICApXG5cbiAgY29uc3Qgc3Vic2NyaWJlQmF0Y2gkID0gYmF0Y2hFeGVjdXRlJC5waXBlKFxuICAgIHdpdGhMYXRlc3RGcm9tKHN0YXRlJCksXG4gICAgbWVyZ2VNYXAoKFt7IHBheWxvYWQgfSwgc3RhdGVdKSA9PiB7XG4gICAgICBjb25zdCBhY3Rpb25zVG9EaXNwYXRjaDogQW55QWN0aW9uW10gPSBbXVxuXG4gICAgICBjb25zdCBiYXRjaGFibGVQcm9wZXJ0eVBhdGggPSBwYXlsb2FkLnJlc3VsdD8uZGVidWc/LmJhdGNoYWJsZVByb3BlcnR5UGF0aFxuXG4gICAgICAvLyBXZSB3YW50IHRoZSBrZXkgdG8gYmUgY29uc2lzdGVudC4gU28gd2Ugb21pdCBiYXRjaGFibGUgcGF0aHMuXG4gICAgICAvLyBPdGhlcndpc2UgaXQgd291bGQgY2hhbmdlIG9uIGV2ZXJ5IG5ldyBjaGlsZFxuICAgICAgY29uc3QgYmF0Y2hXYXJtZXJTdWJzY3JpcHRpb25LZXkgPSBnZXRTdWJzY3JpcHRpb25LZXkoXG4gICAgICAgIG9taXQoXG4gICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICBiYXRjaGFibGVQcm9wZXJ0eVBhdGg/Lm1hcCgoeyBuYW1lIH0pID0+IGBkYXRhLiR7bmFtZX1gKSxcbiAgICAgICAgKSxcbiAgICAgIClcblxuICAgICAgY29uc3QgZXhpc3RpbmdCYXRjaFdhcm1lciA9IHN0YXRlLmNhY2hlV2FybWVyLnN1YnNjcmlwdGlvbnNbYmF0Y2hXYXJtZXJTdWJzY3JpcHRpb25LZXldXG5cbiAgICAgIC8vIFN0YXJ0IHBsYWNlaG9sZGVyIHN1YnNjcmlwdGlvbnMgZm9yIGNoaWxkcmVuXG4gICAgICBjb25zdCBjaGlsZExhc3RTZWVuQnlJZDogeyBbY2hpbGRLZXk6IHN0cmluZ106IG51bWJlciB9ID0ge31cbiAgICAgIC8vIElmIHJlc3VsdCB3YXMgZnJvbSBhIGJhdGNoIHJlcXVlc3RcbiAgICAgIGlmIChwYXlsb2FkLnJlc3VsdD8uZGF0YT8ucmVzdWx0cykge1xuICAgICAgICBjb25zdCBtZW1iZXJzID0gW11cbiAgICAgICAgZm9yIChjb25zdCBbcmVxdWVzdF0gb2YgT2JqZWN0LnZhbHVlczxbQWRhcHRlclJlcXVlc3QsIG51bWJlcl0+KFxuICAgICAgICAgIHBheWxvYWQucmVzdWx0LmRhdGEucmVzdWx0cyxcbiAgICAgICAgKSkge1xuICAgICAgICAgIGNvbnN0IHdhcm11cFN1YnNjcmliZWRQYXlsb2FkQ2hpbGQgPSB7XG4gICAgICAgICAgICAuLi5wYXlsb2FkLFxuICAgICAgICAgICAgLi4ucmVxdWVzdCxcbiAgICAgICAgICAgIHBhcmVudDogYmF0Y2hXYXJtZXJTdWJzY3JpcHRpb25LZXksXG4gICAgICAgICAgICBiYXRjaGFibGVQcm9wZXJ0eVBhdGgsXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGNoaWxkS2V5ID0gZ2V0U3Vic2NyaXB0aW9uS2V5KHdhcm11cFN1YnNjcmliZWRQYXlsb2FkQ2hpbGQpXG4gICAgICAgICAgY2hpbGRMYXN0U2VlbkJ5SWRbY2hpbGRLZXldID0gRGF0ZS5ub3coKVxuICAgICAgICAgIG1lbWJlcnMucHVzaCh3YXJtdXBTdWJzY3JpYmVkUGF5bG9hZENoaWxkKVxuICAgICAgICB9XG4gICAgICAgIGFjdGlvbnNUb0Rpc3BhdGNoLnB1c2god2FybXVwU3Vic2NyaWJlZE11bHRpcGxlKHsgbWVtYmVycyB9KSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHdhcm11cFN1YnNjcmliZWRQYXlsb2FkQ2hpbGQgPSB7XG4gICAgICAgICAgLi4ucGF5bG9hZCxcbiAgICAgICAgICBwYXJlbnQ6IGJhdGNoV2FybWVyU3Vic2NyaXB0aW9uS2V5LFxuICAgICAgICAgIGJhdGNoYWJsZVByb3BlcnR5UGF0aCxcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGlsZEtleSA9IGdldFN1YnNjcmlwdGlvbktleSh3YXJtdXBTdWJzY3JpYmVkUGF5bG9hZENoaWxkKVxuICAgICAgICBjaGlsZExhc3RTZWVuQnlJZFtjaGlsZEtleV0gPSBEYXRlLm5vdygpXG4gICAgICAgIGFjdGlvbnNUb0Rpc3BhdGNoLnB1c2god2FybXVwU3Vic2NyaWJlZCh3YXJtdXBTdWJzY3JpYmVkUGF5bG9hZENoaWxkKSlcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYmF0Y2ggd2FybWVyIGFscmVhZHkgZXhpc3RzIGpvaW4gaXQgYnkgYWRkaW5nIGNoaWxkTGFzdFNlZW5CeUlkIHRvIHJlcXVlc3QgZGF0YVxuICAgICAgaWYgKGV4aXN0aW5nQmF0Y2hXYXJtZXIgJiYgYmF0Y2hhYmxlUHJvcGVydHlQYXRoKSB7XG4gICAgICAgIGFjdGlvbnNUb0Rpc3BhdGNoLnB1c2goXG4gICAgICAgICAgd2FybXVwSm9pbkdyb3VwKHtcbiAgICAgICAgICAgIHBhcmVudDogYmF0Y2hXYXJtZXJTdWJzY3JpcHRpb25LZXksXG4gICAgICAgICAgICBjaGlsZExhc3RTZWVuQnlJZDogY2hpbGRMYXN0U2VlbkJ5SWQsXG4gICAgICAgICAgICBiYXRjaGFibGVQcm9wZXJ0eVBhdGgsXG4gICAgICAgICAgfSksXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIC8vIElmIGJhdGNoIHdhcm1lciBkb2VzIG5vdCBleGlzdCwgc3RhcnQgaXRcbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBJZiBpbmNvbWluZyBiYXRjaGFibGUgcmVxdWVzdCBwYXJhbWV0ZXJzIGFyZW4ndCBhbiBhcnJheSwgdHJhbnNmb3JtIGludG8gb25lXG4gICAgICAgIGxldCBiYXRjaFdhcm1lckRhdGEgPSB7XG4gICAgICAgICAgLi4ucGF5bG9hZC5kYXRhLFxuICAgICAgICAgIHJlc3VsdFBhdGg6IHVuZGVmaW5lZCxcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHsgbmFtZSB9IG9mIGJhdGNoYWJsZVByb3BlcnR5UGF0aCB8fCBbXSkge1xuICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShiYXRjaFdhcm1lckRhdGFbbmFtZV0pKVxuICAgICAgICAgICAgYmF0Y2hXYXJtZXJEYXRhID0ge1xuICAgICAgICAgICAgICAuLi5iYXRjaFdhcm1lckRhdGEsXG4gICAgICAgICAgICAgIFtuYW1lXTogW2JhdGNoV2FybWVyRGF0YVtuYW1lXV0sXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhY3Rpb25zVG9EaXNwYXRjaC5wdXNoKFxuICAgICAgICAgIHdhcm11cFN1YnNjcmliZWQoe1xuICAgICAgICAgICAgLi4ucGF5bG9hZCxcbiAgICAgICAgICAgIGRhdGE6IGJhdGNoV2FybWVyRGF0YSxcbiAgICAgICAgICAgIGtleTogYmF0Y2hXYXJtZXJTdWJzY3JpcHRpb25LZXksXG4gICAgICAgICAgICBjaGlsZExhc3RTZWVuQnlJZCxcbiAgICAgICAgICAgIGJhdGNoYWJsZVByb3BlcnR5UGF0aCxcbiAgICAgICAgICB9KSxcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnJvbShhY3Rpb25zVG9EaXNwYXRjaClcbiAgICB9KSxcbiAgKVxuXG4gIGNvbnN0IHN1YnNjcmliZUluZGl2aWR1YWwkID0gZXhlY3V0ZSQucGlwZShtYXAoKHsgcGF5bG9hZCB9KSA9PiB3YXJtdXBTdWJzY3JpYmVkKHBheWxvYWQpKSlcblxuICByZXR1cm4gbWVyZ2Uoc3Vic2NyaWJlQmF0Y2gkLCBzdWJzY3JpYmVJbmRpdmlkdWFsJClcbn1cblxuZXhwb3J0IGNvbnN0IHdhcm11cFN1YnNjcmliZXI6IEVwaWM8QW55QWN0aW9uLCBBbnlBY3Rpb24sIGFueSwgRXBpY0RlcGVuZGVuY2llcz4gPSAoXG4gIGFjdGlvbiQsXG4gIHN0YXRlJCxcbiAgeyBjb25maWcgfSxcbikgPT5cbiAgYWN0aW9uJC5waXBlKFxuICAgIGZpbHRlcih3YXJtdXBTdWJzY3JpYmVkLm1hdGNoKSxcbiAgICBtYXAoKHsgcGF5bG9hZCB9KSA9PiAoe1xuICAgICAgcGF5bG9hZCxcbiAgICAgIGtleTogcGF5bG9hZC5rZXkgfHwgZ2V0U3Vic2NyaXB0aW9uS2V5KHBheWxvYWQpLFxuICAgIH0pKSxcbiAgICB3aXRoTGF0ZXN0RnJvbShzdGF0ZSQpLFxuICAgIC8vIGNoZWNrIGlmIHRoZSBzdWJzY3JpcHRpb24gYWxyZWFkeSBleGlzdHMsIHRoZW4gbm9vcFxuICAgIGZpbHRlcigoW3sgcGF5bG9hZCwga2V5IH0sIHN0YXRlXSkgPT4ge1xuICAgICAgLy8gaWYgYSBjaGlsZCwgcmVnaXN0ZXIsIGJ1dCBkb24ndCB3YXJtXG4gICAgICBpZiAocGF5bG9hZC5wYXJlbnQpIHJldHVybiBmYWxzZVxuICAgICAgLy8gaWYgc3Vic2NyaXB0aW9uIGRvZXMgbm90IGV4aXN0LCB0aGVuIGNvbnRpbnVlXG4gICAgICAvLyB0aGlzIGNoZWNrIGRvZXNudCB3b3JrIGJlY2F1c2Ugc3RhdGUgaXMgYWxyZWFkeSBzZXQhXG4gICAgICByZXR1cm4gIXN0YXRlLmNhY2hlV2FybWVyLnN1YnNjcmlwdGlvbnNba2V5XT8uaXNEdXBsaWNhdGVcbiAgICB9KSxcbiAgICB0YXAoKFt7IHBheWxvYWQgfV0pID0+IHtcbiAgICAgIGNvbnN0IGxhYmVscyA9IHtcbiAgICAgICAgaXNCYXRjaGVkOiBTdHJpbmcoISFwYXlsb2FkLmNoaWxkTGFzdFNlZW5CeUlkKSxcbiAgICAgIH1cbiAgICAgIG1ldHJpY3MuY2FjaGVfd2FybWVyX2NvdW50LmxhYmVscyhsYWJlbHMpLmluYygpXG4gICAgfSksXG4gICAgLy8gb24gYSBzdWJzY3JpYmUgYWN0aW9uIGJlaW5nIGRpc3BhdGNoZWQsIHNwaW4gdXAgYSBsb25nIGxpdmVkIGludGVydmFsIGlmIG9uZSBkb2VzbnQgZXhpc3QgeWV0XG4gICAgbWVyZ2VNYXAoKFt7IHBheWxvYWQsIGtleSB9XSkgPT4ge1xuICAgICAgLy8gSW50ZXJ2YWwgc2hvdWxkIGJlIHNldCB0byB0aGUgd2FybXVwIGludGVydmFsIGlmIGNvbmZpZ3VyZWQsXG4gICAgICAvLyBvdGhlcndpc2UgdXNlIHRoZSBUVEwgZnJvbSB0aGUgcmVxdWVzdC5cbiAgICAgIGNvbnN0IGludGVydmFsID0gY29uZmlnLndhcm11cEludGVydmFsIHx8IGdldFRUTChwYXlsb2FkKVxuICAgICAgY29uc3Qgb2Zmc2V0ID0gTWF0aC5taW4oaW50ZXJ2YWwsIDEwMDApXG4gICAgICBjb25zdCBwb2xsSW50ZXJ2YWwgPSBpbnRlcnZhbCAtIG9mZnNldFxuICAgICAgcmV0dXJuIHRpbWVyKHBvbGxJbnRlcnZhbCwgcG9sbEludGVydmFsKS5waXBlKFxuICAgICAgICBtYXBUbyh3YXJtdXBSZXF1ZXN0ZWQoeyBrZXkgfSkpLFxuICAgICAgICAvLyB1bnN1YnNjcmliZSBvdXIgd2FybXVwIGFsZ28gd2hlbiBhIG1hdGNoaW5nIHVuc3Vic2NyaWJlIGNvbWVzIGluXG4gICAgICAgIHRha2VVbnRpbChcbiAgICAgICAgICBhY3Rpb24kLnBpcGUoXG4gICAgICAgICAgICBmaWx0ZXIod2FybXVwVW5zdWJzY3JpYmVkLm1hdGNoIHx8IHdhcm11cFN0b3BwZWQubWF0Y2gpLFxuICAgICAgICAgICAgZmlsdGVyKChhKSA9PiBhLnBheWxvYWQua2V5ID09PSBrZXkpLFxuICAgICAgICAgICAgd2l0aExhdGVzdEZyb20oc3RhdGUkKSxcbiAgICAgICAgICAgIHRhcCgoW3sgcGF5bG9hZCB9LCBzdGF0ZV0pID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbGFiZWxzID0ge1xuICAgICAgICAgICAgICAgIGlzQmF0Y2hlZDogU3RyaW5nKFxuICAgICAgICAgICAgICAgICAgISFzdGF0ZS5jYWNoZVdhcm1lci5zdWJzY3JpcHRpb25zW3BheWxvYWQua2V5XT8uY2hpbGRMYXN0U2VlbkJ5SWQsXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBtZXRyaWNzLmNhY2hlX3dhcm1lcl9jb3VudC5sYWJlbHMobGFiZWxzKS5kZWMoKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgKSxcbiAgICAgICAgKSxcbiAgICAgIClcbiAgICB9KSxcbiAgKVxuXG4vKipcbiAqIEhhbmRsZSB3YXJtdXAgcmVzcG9uc2UgcmVxdWVzdCBldmVudHNcbiAqL1xuZXhwb3J0IGNvbnN0IHdhcm11cFJlcXVlc3RIYW5kbGVyOiBFcGljPEFueUFjdGlvbiwgQW55QWN0aW9uLCBhbnk+ID0gKGFjdGlvbiQsIHN0YXRlJCkgPT5cbiAgYWN0aW9uJC5waXBlKFxuICAgIC8vIHRoaXMgcGlwZWxpbmUgd2lsbCBleGVjdXRlIHdoZW4gd2UgaGF2ZSBhIHJlcXVlc3QgdG8gd2FybSB1cCBhbiBhZGFwdGVyXG4gICAgZmlsdGVyKHdhcm11cFJlcXVlc3RlZC5tYXRjaCksXG4gICAgLy8gZmV0Y2ggb3VyIHJlcXVpcmVkIHN0YXRlIHRvIG1ha2UgYSByZXF1ZXN0IHRvIHdhcm0gdXAgYW4gYWRhcHRlclxuICAgIHdpdGhMYXRlc3RGcm9tKHN0YXRlJCksXG4gICAgbWFwKChbYWN0aW9uLCBzdGF0ZV0pID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlcXVlc3REYXRhOiBzdGF0ZS5jYWNoZVdhcm1lci5zdWJzY3JpcHRpb25zW2FjdGlvbi5wYXlsb2FkLmtleV0sXG4gICAgICAgIGtleTogYWN0aW9uLnBheWxvYWQua2V5LFxuICAgICAgICBzdWJzY3JpcHRpb25zOiBzdGF0ZS5jYWNoZVdhcm1lci5zdWJzY3JpcHRpb25zLFxuICAgICAgfVxuICAgIH0pLFxuICAgIGZpbHRlcigoeyByZXF1ZXN0RGF0YSB9KSA9PiAhIXJlcXVlc3REYXRhKSxcbiAgICAvLyBtYWtlIHRoZSByZXF1ZXN0XG4gICAgbWVyZ2VNYXAoKHsgcmVxdWVzdERhdGEsIGtleSB9KSA9PlxuICAgICAgZnJvbShcbiAgICAgICAgcmVxdWVzdERhdGEuYmF0Y2hhYmxlUHJvcGVydHlQYXRoXG4gICAgICAgICAgPyAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBiYXRjaGVzID0gc3BsaXRJbnRvQmF0Y2hlcyhyZXF1ZXN0RGF0YSlcbiAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdHMgPSBbXVxuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGJhdGNoIG9mIE9iamVjdC52YWx1ZXMoYmF0Y2hlcykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgLi4ucmVxdWVzdERhdGEub3JpZ2luLFxuICAgICAgICAgICAgICAgICAgLi4uYmF0Y2gsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcXVlc3RzLnB1c2goXG4gICAgICAgICAgICAgICAgICByZXF1ZXN0RGF0YS5leGVjdXRlRm4oe1xuICAgICAgICAgICAgICAgICAgICBpZDogcmVxdWVzdERhdGEuY2hpbGRMYXN0U2VlbkJ5SWQgPyBXQVJNVVBfQkFUQ0hfUkVRVUVTVF9JRCA6IFdBUk1VUF9SRVFVRVNUX0lELFxuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICBkZWJ1ZzogeyB3YXJtZXI6IHRydWUgfSxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCBQcm9taXNlLmFsbChyZXF1ZXN0cylcbiAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG51bGxcbiAgICAgICAgICAgICAgZm9yIChjb25zdCByZXNwIG9mIHJlc3BvbnNlcykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNvbmNhdGVuYXRlQmF0Y2hSZXN1bHRzKHJlc3VsdCwgcmVzcClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgICAgICB9KSgpXG4gICAgICAgICAgOiByZXF1ZXN0RGF0YS5leGVjdXRlRm4oe1xuICAgICAgICAgICAgICBpZDogcmVxdWVzdERhdGEuY2hpbGRMYXN0U2VlbkJ5SWQgPyBXQVJNVVBfQkFUQ0hfUkVRVUVTVF9JRCA6IFdBUk1VUF9SRVFVRVNUX0lELFxuICAgICAgICAgICAgICBkYXRhOiB7IC4uLnJlcXVlc3REYXRhLm9yaWdpbiB9LFxuICAgICAgICAgICAgICBkZWJ1ZzogeyB3YXJtZXI6IHRydWUgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgKS5waXBlKFxuICAgICAgICBtYXBUbyh3YXJtdXBGdWxmaWxsZWQoeyBrZXkgfSkpLFxuICAgICAgICBjYXRjaEVycm9yKChlcnJvcjogdW5rbm93bikgPT5cbiAgICAgICAgICBvZihcbiAgICAgICAgICAgIHdhcm11cEZhaWxlZCh7XG4gICAgICAgICAgICAgIGZlZWRMYWJlbDogZ2V0RmVlZElkKHtcbiAgICAgICAgICAgICAgICBpZDogcmVxdWVzdERhdGEuY2hpbGRMYXN0U2VlbkJ5SWQgPyBXQVJNVVBfQkFUQ0hfUkVRVUVTVF9JRCA6IFdBUk1VUF9SRVFVRVNUX0lELFxuICAgICAgICAgICAgICAgIGRhdGE6IHJlcXVlc3REYXRhPy5vcmlnaW4sXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBlcnJvcjogZXJyb3IgYXMgRXJyb3IsXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICksXG4gICAgICAgICksXG4gICAgICApLFxuICAgICksXG4gIClcblxuLy8gd2UgY2FuIGNvbWJpbmUgdGhpcyBpbnRvIG9uZSBvZiB0aGUgYWJvdmUgZXBpY3MgaWYgd2UgaGF2ZSBwZXJmb3JtYW5jZSBpc3N1ZXMgbGF0ZXIgb25cbmV4cG9ydCBjb25zdCB3YXJtdXBVbnN1YnNjcmliZXI6IEVwaWM8QW55QWN0aW9uLCBBbnlBY3Rpb24sIGFueSwgRXBpY0RlcGVuZGVuY2llcz4gPSAoXG4gIGFjdGlvbiQsXG4gIHN0YXRlJCxcbiAgeyBjb25maWcgfSxcbikgPT4ge1xuICBjb25zdCB1bnN1YnNjcmliZU9uRmFpbHVyZSQgPSBhY3Rpb24kLnBpcGUoXG4gICAgZmlsdGVyKHdhcm11cEZhaWxlZC5tYXRjaCksXG4gICAgd2l0aExhdGVzdEZyb20oc3RhdGUkKSxcbiAgICBmaWx0ZXIoXG4gICAgICAoW3sgcGF5bG9hZCB9LCBzdGF0ZV0pID0+XG4gICAgICAgIChzdGF0ZS5jYWNoZVdhcm1lci53YXJtdXBzW3BheWxvYWQua2V5XT8uZXJyb3JDb3VudCA/PyAwID49IGNvbmZpZy51bmhlYWx0aHlUaHJlc2hvbGQpICYmXG4gICAgICAgIGNvbmZpZy51bmhlYWx0aHlUaHJlc2hvbGQgIT09IC0xLFxuICAgICksXG4gICAgbWFwKChbeyBwYXlsb2FkIH1dKSA9PlxuICAgICAgd2FybXVwVW5zdWJzY3JpYmVkKHsga2V5OiBwYXlsb2FkLmtleSwgcmVhc29uOiBgRXJyb3JlZDogJHtwYXlsb2FkLmVycm9yLm1lc3NhZ2V9YCB9KSxcbiAgICApLFxuICApXG5cbiAgLy8gZW1pdHMgd2hlbmV2ZXIgYSBzdWJzY3JpcHRpb24gZXZlbnQgY29tZXMgaW4sXG4gIC8vIHVzZWQgYXMgYSBoZWxwZXIgc3RyZWFtIGZvciB0aGUgdGltZW91dCBsaW1pdCBzdHJlYW1cbiAgY29uc3Qga2V5ZWRTdWJzY3JpcHRpb24kID0gYWN0aW9uJC5waXBlKFxuICAgIGZpbHRlcih3YXJtdXBTdWJzY3JpYmVkLm1hdGNoKSxcbiAgICBtYXAoKHsgcGF5bG9hZCB9KSA9PiAoeyBwYXlsb2FkLCBrZXk6IGdldFN1YnNjcmlwdGlvbktleShwYXlsb2FkKSB9KSksXG4gIClcblxuICBjb25zdCB1bnN1YnNjcmliZU9uVGltZW91dCQgPSBrZXllZFN1YnNjcmlwdGlvbiQucGlwZShcbiAgICAvLyB3aGVuIGEgc3Vic2NyaXB0aW9uIGNvbWVzIGluXG4gICAgbWVyZ2VNYXAoKHsga2V5IH0pID0+IHtcbiAgICAgIC8vIHdlIGxvb2sgZm9yIG1hdGNoaW5nIHN1YnNjcmlwdGlvbnMgb2YgdGhlIHNhbWUgdHlwZVxuICAgICAgLy8gd2hpY2ggZGVhY3RpdmF0ZXMgdGhlIGN1cnJlbnQgdGltZXJcbiAgICAgIGNvbnN0IHJlc2V0JCA9IGtleWVkU3Vic2NyaXB0aW9uJC5waXBlKFxuICAgICAgICBmaWx0ZXIoKHsga2V5OiBrZXlCIH0pID0+IGtleSA9PT0ga2V5QiksXG4gICAgICAgIHRha2UoMSksXG4gICAgICAgIG1hcFRvKHdhcm11cFN1YnNjcmlwdGlvblRpbWVvdXRSZXNldCh7IGtleSB9KSksXG4gICAgICApXG5cbiAgICAgIC8vIHN0YXJ0IHRoZSBjdXJyZW50IHVuc3Vic2NyaXB0aW9uIHRpbWVyXG4gICAgICBjb25zdCB0aW1lb3V0JCA9IG9mKHdhcm11cFVuc3Vic2NyaWJlZCh7IGtleSwgcmVhc29uOiAnVGltZW91dCcgfSkpLnBpcGUoXG4gICAgICAgIGRlbGF5KGNvbmZpZy5zdWJzY3JpcHRpb25UVEwpLFxuICAgICAgKVxuXG4gICAgICAvLyBpZiBhIHJlLXN1YnNjcmlwdGlvbiBjb21lcyBpbiBiZWZvcmUgdGltZW91dCBlbWl0cywgdGhlbiB3ZSBlbWl0IG5vdGhpbmdcbiAgICAgIC8vIGVsc2Ugd2UgdW5zdWJzY3JpYmUgZnJvbSB0aGUgY3VycmVudCBzdWJzY3JpcHRpb25cbiAgICAgIHJldHVybiByYWNlKHJlc2V0JCwgdGltZW91dCQpXG4gICAgfSksXG4gIClcblxuICBjb25zdCBzdG9wT25CYXRjaCQgPSBrZXllZFN1YnNjcmlwdGlvbiQucGlwZShcbiAgICAvLyB3aGVuIGEgc3Vic2NyaXB0aW9uIGNvbWVzIGluLCBpZiBpdCBoYXMgY2hpbGRyZW5cbiAgICBmaWx0ZXIoKHsgcGF5bG9hZCB9KSA9PiAhIXBheWxvYWQ/LmNoaWxkTGFzdFNlZW5CeUlkKSxcbiAgICBtZXJnZU1hcCgoeyBwYXlsb2FkIH0pID0+IFtcbiAgICAgIHdhcm11cFN0b3BwZWQoeyBrZXlzOiBPYmplY3Qua2V5cyhwYXlsb2FkPy5jaGlsZExhc3RTZWVuQnlJZCB8fCB7fSkgfSksXG4gICAgXSksXG4gIClcblxuICBjb25zdCB1bnN1YnNjcmliZU9uQmF0Y2hFbXB0eSQgPSBhY3Rpb24kLnBpcGUoXG4gICAgZmlsdGVyKHdhcm11cExlYXZlR3JvdXAubWF0Y2gpLFxuICAgIHdpdGhMYXRlc3RGcm9tKHN0YXRlJCksXG4gICAgZmlsdGVyKChbeyBwYXlsb2FkIH0sIHN0YXRlXSkgPT4ge1xuICAgICAgZm9yIChjb25zdCB7IG5hbWUgfSBvZiBwYXlsb2FkLmJhdGNoYWJsZVByb3BlcnR5UGF0aCkge1xuICAgICAgICBpZiAoc3RhdGUuY2FjaGVXYXJtZXIuc3Vic2NyaXB0aW9uc1twYXlsb2FkLnBhcmVudF0ub3JpZ2luW25hbWVdLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0pLFxuICAgIG1hcCgoW3sgcGF5bG9hZCB9XSkgPT5cbiAgICAgIHdhcm11cFVuc3Vic2NyaWJlZCh7IGtleTogcGF5bG9hZC5wYXJlbnQsIHJlYXNvbjogJ0VtcHR5IEJhdGNoIFdhcm1lciByZXF1ZXN0IGRhdGEnIH0pLFxuICAgICksXG4gIClcblxuICByZXR1cm4gbWVyZ2UodW5zdWJzY3JpYmVPbkZhaWx1cmUkLCB1bnN1YnNjcmliZU9uVGltZW91dCQsIHN0b3BPbkJhdGNoJCwgdW5zdWJzY3JpYmVPbkJhdGNoRW1wdHkkKVxufVxuXG5leHBvcnQgY29uc3Qgcm9vdEVwaWMgPSBjb21iaW5lRXBpY3MoXG4gIGV4ZWN1dGVIYW5kbGVyLFxuICB3YXJtdXBTdWJzY3JpYmVyLFxuICB3YXJtdXBVbnN1YnNjcmliZXIsXG4gIHdhcm11cFJlcXVlc3RIYW5kbGVyLFxuKVxuXG5leHBvcnQgY29uc3QgZXBpY01pZGRsZXdhcmUgPSBjcmVhdGVFcGljTWlkZGxld2FyZTxhbnksIGFueSwgYW55LCBFcGljRGVwZW5kZW5jaWVzPih7XG4gIGRlcGVuZGVuY2llczogeyBjb25maWc6IGdldCgpIH0sXG59KVxuIl19