"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withRateLimit = exports.maxAgeFor = exports.makeId = exports.computeThroughput = exports.reducer = exports.actions = void 0;
const tslib_1 = require("tslib");
const util_1 = require("../util");
const actions_1 = require("./actions");
const metrics = tslib_1.__importStar(require("./metrics"));
const reducer_1 = require("./reducer");
exports.actions = tslib_1.__importStar(require("./actions"));
exports.reducer = tslib_1.__importStar(require("./reducer"));
/**
 * Calculates how much capacity a participant deserves based on its weight on the adapter
 * @param state Redux Heartbeats state
 * @param interval Time window size to get heartbeats
 * @param id Participant ID to get participants heartbeats
 */
const computeThroughput = (config, state, interval, id) => {
    // All observed in interval
    const totalThroughtput = reducer_1.selectTotalNumberOfHeartbeatsFor(state, interval);
    // All of type observed in interval
    const observedRequestsOfParticipant = reducer_1.selectParticiantsHeartbeatsFor(state, interval, id);
    const throughputOfParticipant = observedRequestsOfParticipant.length + 1;
    const costOfParticipant = getAverageCost(observedRequestsOfParticipant) || 1;
    // Compute max throughput by weight
    const weight = throughputOfParticipant / totalThroughtput;
    return maxThroughput(weight, costOfParticipant, config.totalCapacity);
};
exports.computeThroughput = computeThroughput;
const getAverageCost = (requests) => {
    if (!requests || requests.length === 0)
        return 0;
    return requests.reduce((totalCost, h) => totalCost + h.c, 0) / requests.length;
};
const maxThroughput = (weight, cost, totalCapacity) => {
    const maxAllowedCapacity = 0.9 * (totalCapacity / cost);
    return weight * maxAllowedCapacity;
};
/**
 * Returns hash of the input request payload excluding some volatile paths
 *
 * @param request payload
 */
const makeId = (request) => util_1.hash(request, util_1.getHashOpts());
exports.makeId = makeId;
/**
 * Calculate maxAge to keep the item cached so we allow the specified throughput.
 *
 * @param throughput number of allowed requests in interval
 * @param interval time window in ms
 */
const maxAgeFor = (throughput, interval) => throughput <= 0 ? interval : Math.floor(interval / throughput);
exports.maxAgeFor = maxAgeFor;
const withRateLimit = (store) => async (execute, context) => async (input) => {
    const config = context.rateLimit ?? {};
    if (!config.enabled)
        return await execute(input, context);
    let state = store.getState();
    const { heartbeats } = state;
    const requestTypeId = exports.makeId(input);
    const maxThroughput = exports.computeThroughput(config, heartbeats, reducer_1.IntervalNames.HOUR, requestTypeId);
    const maxAge = exports.maxAgeFor(maxThroughput, reducer_1.Intervals[reducer_1.IntervalNames.MINUTE]);
    const result = await execute({ ...input, rateLimitMaxAge: maxAge }, context);
    store.dispatch(actions_1.successfulResponseObserved(input, result));
    state = store.getState();
    const defaultLabels = {
        feed_id: input.metricsMeta?.feedId ?? 'N/A',
        participant_id: requestTypeId,
        experimental: 'true',
    };
    const cost = result.debug?.providerCost || 1;
    metrics.rateLimitCreditsSpentTotal.labels(defaultLabels).inc(isNaN(cost) ? 1 : cost);
    return result;
};
exports.withRateLimit = withRateLimit;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3JhdGUtbGltaXQvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUVBLGtDQUEyQztBQUMzQyx1Q0FBc0Q7QUFFdEQsMkRBQW9DO0FBQ3BDLHVDQVFrQjtBQUNsQiw2REFBb0M7QUFDcEMsNkRBQW9DO0FBRXBDOzs7OztHQUtHO0FBQ0ksTUFBTSxpQkFBaUIsR0FBRyxDQUMvQixNQUFjLEVBQ2QsS0FBaUIsRUFDakIsUUFBdUIsRUFDdkIsRUFBVSxFQUNGLEVBQUU7SUFDViwyQkFBMkI7SUFDM0IsTUFBTSxnQkFBZ0IsR0FBRywwQ0FBZ0MsQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLENBQUE7SUFDMUUsbUNBQW1DO0lBQ25DLE1BQU0sNkJBQTZCLEdBQUcsd0NBQThCLENBQUMsS0FBSyxFQUFFLFFBQVEsRUFBRSxFQUFFLENBQUMsQ0FBQTtJQUN6RixNQUFNLHVCQUF1QixHQUFHLDZCQUE2QixDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUE7SUFDeEUsTUFBTSxpQkFBaUIsR0FBRyxjQUFjLENBQUMsNkJBQTZCLENBQUMsSUFBSSxDQUFDLENBQUE7SUFDNUUsbUNBQW1DO0lBQ25DLE1BQU0sTUFBTSxHQUFHLHVCQUF1QixHQUFHLGdCQUFnQixDQUFBO0lBRXpELE9BQU8sYUFBYSxDQUFDLE1BQU0sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUE7QUFDdkUsQ0FBQyxDQUFBO0FBaEJZLFFBQUEsaUJBQWlCLHFCQWdCN0I7QUFFRCxNQUFNLGNBQWMsR0FBRyxDQUFDLFFBQXFCLEVBQVUsRUFBRTtJQUN2RCxJQUFJLENBQUMsUUFBUSxJQUFJLFFBQVEsQ0FBQyxNQUFNLEtBQUssQ0FBQztRQUFFLE9BQU8sQ0FBQyxDQUFBO0lBQ2hELE9BQU8sUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLFNBQVMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxNQUFNLENBQUE7QUFDaEYsQ0FBQyxDQUFBO0FBRUQsTUFBTSxhQUFhLEdBQUcsQ0FBQyxNQUFjLEVBQUUsSUFBWSxFQUFFLGFBQXFCLEVBQVUsRUFBRTtJQUNwRixNQUFNLGtCQUFrQixHQUFHLEdBQUcsR0FBRyxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsQ0FBQTtJQUN2RCxPQUFPLE1BQU0sR0FBRyxrQkFBa0IsQ0FBQTtBQUNwQyxDQUFDLENBQUE7QUFFRDs7OztHQUlHO0FBQ0ksTUFBTSxNQUFNLEdBQUcsQ0FBQyxPQUF1QixFQUFVLEVBQUUsQ0FBQyxXQUFJLENBQUMsT0FBTyxFQUFFLGtCQUFXLEVBQUUsQ0FBQyxDQUFBO0FBQTFFLFFBQUEsTUFBTSxVQUFvRTtBQUV2Rjs7Ozs7R0FLRztBQUNJLE1BQU0sU0FBUyxHQUFHLENBQUMsVUFBa0IsRUFBRSxRQUFnQixFQUFVLEVBQUUsQ0FDeEUsVUFBVSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsR0FBRyxVQUFVLENBQUMsQ0FBQTtBQURuRCxRQUFBLFNBQVMsYUFDMEM7QUFFekQsTUFBTSxhQUFhLEdBQ3hCLENBQUMsS0FBdUIsRUFBYyxFQUFFLENBQ3hDLEtBQUssRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLEVBQUUsQ0FDM0IsS0FBSyxFQUFFLEtBQUssRUFBRSxFQUFFO0lBQ2QsTUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLFNBQVMsSUFBSSxFQUFFLENBQUE7SUFDdEMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPO1FBQUUsT0FBTyxNQUFNLE9BQU8sQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUE7SUFDekQsSUFBSSxLQUFLLEdBQUcsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFBO0lBQzVCLE1BQU0sRUFBRSxVQUFVLEVBQUUsR0FBRyxLQUFLLENBQUE7SUFDNUIsTUFBTSxhQUFhLEdBQUcsY0FBTSxDQUFDLEtBQUssQ0FBQyxDQUFBO0lBQ25DLE1BQU0sYUFBYSxHQUFHLHlCQUFpQixDQUFDLE1BQU0sRUFBRSxVQUFVLEVBQUUsdUJBQWEsQ0FBQyxJQUFJLEVBQUUsYUFBYSxDQUFDLENBQUE7SUFDOUYsTUFBTSxNQUFNLEdBQUcsaUJBQVMsQ0FBQyxhQUFhLEVBQUUsbUJBQVMsQ0FBQyx1QkFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUE7SUFDeEUsTUFBTSxNQUFNLEdBQUcsTUFBTSxPQUFPLENBQUMsRUFBRSxHQUFHLEtBQUssRUFBRSxlQUFlLEVBQUUsTUFBTSxFQUFFLEVBQUUsT0FBTyxDQUFDLENBQUE7SUFFNUUsS0FBSyxDQUFDLFFBQVEsQ0FBQyxvQ0FBMEIsQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQTtJQUN6RCxLQUFLLEdBQUcsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFBO0lBRXhCLE1BQU0sYUFBYSxHQUFHO1FBQ3BCLE9BQU8sRUFBRSxLQUFLLENBQUMsV0FBVyxFQUFFLE1BQU0sSUFBSSxLQUFLO1FBQzNDLGNBQWMsRUFBRSxhQUFhO1FBQzdCLFlBQVksRUFBRSxNQUFNO0tBQ3JCLENBQUE7SUFDRCxNQUFNLElBQUksR0FBRyxNQUFNLENBQUMsS0FBSyxFQUFFLFlBQVksSUFBSSxDQUFDLENBQUE7SUFDNUMsT0FBTyxDQUFDLDBCQUEwQixDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFBO0lBRXBGLE9BQU8sTUFBTSxDQUFBO0FBQ2YsQ0FBQyxDQUFBO0FBekJVLFFBQUEsYUFBYSxpQkF5QnZCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWRhcHRlclJlcXVlc3QsIE1pZGRsZXdhcmUgfSBmcm9tICdAY2hhaW5saW5rL3R5cGVzJ1xuaW1wb3J0IHsgU3RvcmUgfSBmcm9tICdyZWR1eCdcbmltcG9ydCB7IGdldEhhc2hPcHRzLCBoYXNoIH0gZnJvbSAnLi4vdXRpbCdcbmltcG9ydCB7IHN1Y2Nlc3NmdWxSZXNwb25zZU9ic2VydmVkIH0gZnJvbSAnLi9hY3Rpb25zJ1xuaW1wb3J0IHsgQ29uZmlnIH0gZnJvbSAnLi9jb25maWcnXG5pbXBvcnQgKiBhcyBtZXRyaWNzIGZyb20gJy4vbWV0cmljcydcbmltcG9ydCB7XG4gIEhlYXJ0YmVhdCxcbiAgSGVhcnRiZWF0cyxcbiAgSW50ZXJ2YWxOYW1lcyxcbiAgSW50ZXJ2YWxzLFxuICBSb290U3RhdGUsXG4gIHNlbGVjdFBhcnRpY2lhbnRzSGVhcnRiZWF0c0ZvcixcbiAgc2VsZWN0VG90YWxOdW1iZXJPZkhlYXJ0YmVhdHNGb3IsXG59IGZyb20gJy4vcmVkdWNlcidcbmV4cG9ydCAqIGFzIGFjdGlvbnMgZnJvbSAnLi9hY3Rpb25zJ1xuZXhwb3J0ICogYXMgcmVkdWNlciBmcm9tICcuL3JlZHVjZXInXG5cbi8qKlxuICogQ2FsY3VsYXRlcyBob3cgbXVjaCBjYXBhY2l0eSBhIHBhcnRpY2lwYW50IGRlc2VydmVzIGJhc2VkIG9uIGl0cyB3ZWlnaHQgb24gdGhlIGFkYXB0ZXJcbiAqIEBwYXJhbSBzdGF0ZSBSZWR1eCBIZWFydGJlYXRzIHN0YXRlXG4gKiBAcGFyYW0gaW50ZXJ2YWwgVGltZSB3aW5kb3cgc2l6ZSB0byBnZXQgaGVhcnRiZWF0c1xuICogQHBhcmFtIGlkIFBhcnRpY2lwYW50IElEIHRvIGdldCBwYXJ0aWNpcGFudHMgaGVhcnRiZWF0c1xuICovXG5leHBvcnQgY29uc3QgY29tcHV0ZVRocm91Z2hwdXQgPSAoXG4gIGNvbmZpZzogQ29uZmlnLFxuICBzdGF0ZTogSGVhcnRiZWF0cyxcbiAgaW50ZXJ2YWw6IEludGVydmFsTmFtZXMsXG4gIGlkOiBzdHJpbmcsXG4pOiBudW1iZXIgPT4ge1xuICAvLyBBbGwgb2JzZXJ2ZWQgaW4gaW50ZXJ2YWxcbiAgY29uc3QgdG90YWxUaHJvdWdodHB1dCA9IHNlbGVjdFRvdGFsTnVtYmVyT2ZIZWFydGJlYXRzRm9yKHN0YXRlLCBpbnRlcnZhbClcbiAgLy8gQWxsIG9mIHR5cGUgb2JzZXJ2ZWQgaW4gaW50ZXJ2YWxcbiAgY29uc3Qgb2JzZXJ2ZWRSZXF1ZXN0c09mUGFydGljaXBhbnQgPSBzZWxlY3RQYXJ0aWNpYW50c0hlYXJ0YmVhdHNGb3Ioc3RhdGUsIGludGVydmFsLCBpZClcbiAgY29uc3QgdGhyb3VnaHB1dE9mUGFydGljaXBhbnQgPSBvYnNlcnZlZFJlcXVlc3RzT2ZQYXJ0aWNpcGFudC5sZW5ndGggKyAxXG4gIGNvbnN0IGNvc3RPZlBhcnRpY2lwYW50ID0gZ2V0QXZlcmFnZUNvc3Qob2JzZXJ2ZWRSZXF1ZXN0c09mUGFydGljaXBhbnQpIHx8IDFcbiAgLy8gQ29tcHV0ZSBtYXggdGhyb3VnaHB1dCBieSB3ZWlnaHRcbiAgY29uc3Qgd2VpZ2h0ID0gdGhyb3VnaHB1dE9mUGFydGljaXBhbnQgLyB0b3RhbFRocm91Z2h0cHV0XG5cbiAgcmV0dXJuIG1heFRocm91Z2hwdXQod2VpZ2h0LCBjb3N0T2ZQYXJ0aWNpcGFudCwgY29uZmlnLnRvdGFsQ2FwYWNpdHkpXG59XG5cbmNvbnN0IGdldEF2ZXJhZ2VDb3N0ID0gKHJlcXVlc3RzOiBIZWFydGJlYXRbXSk6IG51bWJlciA9PiB7XG4gIGlmICghcmVxdWVzdHMgfHwgcmVxdWVzdHMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuICByZXR1cm4gcmVxdWVzdHMucmVkdWNlKCh0b3RhbENvc3QsIGgpID0+IHRvdGFsQ29zdCArIGguYywgMCkgLyByZXF1ZXN0cy5sZW5ndGhcbn1cblxuY29uc3QgbWF4VGhyb3VnaHB1dCA9ICh3ZWlnaHQ6IG51bWJlciwgY29zdDogbnVtYmVyLCB0b3RhbENhcGFjaXR5OiBudW1iZXIpOiBudW1iZXIgPT4ge1xuICBjb25zdCBtYXhBbGxvd2VkQ2FwYWNpdHkgPSAwLjkgKiAodG90YWxDYXBhY2l0eSAvIGNvc3QpXG4gIHJldHVybiB3ZWlnaHQgKiBtYXhBbGxvd2VkQ2FwYWNpdHlcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGhhc2ggb2YgdGhlIGlucHV0IHJlcXVlc3QgcGF5bG9hZCBleGNsdWRpbmcgc29tZSB2b2xhdGlsZSBwYXRoc1xuICpcbiAqIEBwYXJhbSByZXF1ZXN0IHBheWxvYWRcbiAqL1xuZXhwb3J0IGNvbnN0IG1ha2VJZCA9IChyZXF1ZXN0OiBBZGFwdGVyUmVxdWVzdCk6IHN0cmluZyA9PiBoYXNoKHJlcXVlc3QsIGdldEhhc2hPcHRzKCkpXG5cbi8qKlxuICogQ2FsY3VsYXRlIG1heEFnZSB0byBrZWVwIHRoZSBpdGVtIGNhY2hlZCBzbyB3ZSBhbGxvdyB0aGUgc3BlY2lmaWVkIHRocm91Z2hwdXQuXG4gKlxuICogQHBhcmFtIHRocm91Z2hwdXQgbnVtYmVyIG9mIGFsbG93ZWQgcmVxdWVzdHMgaW4gaW50ZXJ2YWxcbiAqIEBwYXJhbSBpbnRlcnZhbCB0aW1lIHdpbmRvdyBpbiBtc1xuICovXG5leHBvcnQgY29uc3QgbWF4QWdlRm9yID0gKHRocm91Z2hwdXQ6IG51bWJlciwgaW50ZXJ2YWw6IG51bWJlcik6IG51bWJlciA9PlxuICB0aHJvdWdocHV0IDw9IDAgPyBpbnRlcnZhbCA6IE1hdGguZmxvb3IoaW50ZXJ2YWwgLyB0aHJvdWdocHV0KVxuXG5leHBvcnQgY29uc3Qgd2l0aFJhdGVMaW1pdCA9XG4gIChzdG9yZTogU3RvcmU8Um9vdFN0YXRlPik6IE1pZGRsZXdhcmUgPT5cbiAgYXN5bmMgKGV4ZWN1dGUsIGNvbnRleHQpID0+XG4gIGFzeW5jIChpbnB1dCkgPT4ge1xuICAgIGNvbnN0IGNvbmZpZyA9IGNvbnRleHQucmF0ZUxpbWl0ID8/IHt9XG4gICAgaWYgKCFjb25maWcuZW5hYmxlZCkgcmV0dXJuIGF3YWl0IGV4ZWN1dGUoaW5wdXQsIGNvbnRleHQpXG4gICAgbGV0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKVxuICAgIGNvbnN0IHsgaGVhcnRiZWF0cyB9ID0gc3RhdGVcbiAgICBjb25zdCByZXF1ZXN0VHlwZUlkID0gbWFrZUlkKGlucHV0KVxuICAgIGNvbnN0IG1heFRocm91Z2hwdXQgPSBjb21wdXRlVGhyb3VnaHB1dChjb25maWcsIGhlYXJ0YmVhdHMsIEludGVydmFsTmFtZXMuSE9VUiwgcmVxdWVzdFR5cGVJZClcbiAgICBjb25zdCBtYXhBZ2UgPSBtYXhBZ2VGb3IobWF4VGhyb3VnaHB1dCwgSW50ZXJ2YWxzW0ludGVydmFsTmFtZXMuTUlOVVRFXSlcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBleGVjdXRlKHsgLi4uaW5wdXQsIHJhdGVMaW1pdE1heEFnZTogbWF4QWdlIH0sIGNvbnRleHQpXG5cbiAgICBzdG9yZS5kaXNwYXRjaChzdWNjZXNzZnVsUmVzcG9uc2VPYnNlcnZlZChpbnB1dCwgcmVzdWx0KSlcbiAgICBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKClcblxuICAgIGNvbnN0IGRlZmF1bHRMYWJlbHMgPSB7XG4gICAgICBmZWVkX2lkOiBpbnB1dC5tZXRyaWNzTWV0YT8uZmVlZElkID8/ICdOL0EnLFxuICAgICAgcGFydGljaXBhbnRfaWQ6IHJlcXVlc3RUeXBlSWQsXG4gICAgICBleHBlcmltZW50YWw6ICd0cnVlJyxcbiAgICB9XG4gICAgY29uc3QgY29zdCA9IHJlc3VsdC5kZWJ1Zz8ucHJvdmlkZXJDb3N0IHx8IDFcbiAgICBtZXRyaWNzLnJhdGVMaW1pdENyZWRpdHNTcGVudFRvdGFsLmxhYmVscyhkZWZhdWx0TGFiZWxzKS5pbmMoaXNOYU4oY29zdCkgPyAxIDogY29zdClcblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuIl19