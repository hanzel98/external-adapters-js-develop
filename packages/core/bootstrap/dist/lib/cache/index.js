"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withCache = exports.AdapterCache = exports.redactOptions = exports.defaultOptions = exports.MINIMUM_AGE = exports.DEFAULT_CACHE_ENABLED = void 0;
const tslib_1 = require("tslib");
const external_adapter_1 = require("../external-adapter");
const burst_limit_1 = require("../burst-limit");
const util_1 = require("../util");
const ttl_1 = require("./ttl");
const local = tslib_1.__importStar(require("./local"));
const metrics = tslib_1.__importStar(require("./metrics"));
const redis = tslib_1.__importStar(require("./redis"));
const env = process.env;
exports.DEFAULT_CACHE_ENABLED = true;
const DEFAULT_CACHE_TYPE = 'local';
const DEFAULT_CACHE_KEY_GROUP = util_1.uuid();
// Request coalescing
const DEFAULT_RC_INTERVAL = 100;
const DEFAULT_RC_INTERVAL_MAX = 1000;
const DEFAULT_RC_INTERVAL_COEFFICIENT = 2;
const DEFAULT_RC_ENTROPY_MAX = 0;
const DEFAULT_RC_MAX_RETRIES = 5;
exports.MINIMUM_AGE = 1000 * 60 * 0.5; // 30 seconds
const defaultOptions = () => {
    return {
        enabled: util_1.parseBool(env.CACHE_ENABLED ?? exports.DEFAULT_CACHE_ENABLED),
        cacheImplOptions: defaultCacheImplOptions(),
        cacheBuilder: defaultCacheBuilder(),
        key: {
            group: env.CACHE_KEY_GROUP || DEFAULT_CACHE_KEY_GROUP,
        },
        // Request coalescing
        requestCoalescing: {
            enabled: util_1.parseBool(env.REQUEST_COALESCING_ENABLED),
            // Capped linear back-off: 100, 200, 400, 800, 1000..
            interval: Number(env.REQUEST_COALESCING_INTERVAL) || DEFAULT_RC_INTERVAL,
            intervalMax: Number(env.REQUEST_COALESCING_INTERVAL_MAX) || DEFAULT_RC_INTERVAL_MAX,
            intervalCoefficient: Number(env.REQUEST_COALESCING_INTERVAL_COEFFICIENT) || DEFAULT_RC_INTERVAL_COEFFICIENT,
            // Add entropy to absorb bursts
            entropyMax: Number(env.REQUEST_COALESCING_ENTROPY_MAX) || DEFAULT_RC_ENTROPY_MAX,
            maxRetries: Number(env.REQUEST_COALESCING_MAX_RETRIES) || DEFAULT_RC_MAX_RETRIES,
        },
        minimumAge: Number(env.CACHE_MIN_AGE) || exports.MINIMUM_AGE,
    };
};
exports.defaultOptions = defaultOptions;
const defaultCacheImplOptions = () => {
    const type = env.CACHE_TYPE || DEFAULT_CACHE_TYPE;
    const options = type === 'redis' ? redis.defaultOptions() : local.defaultOptions();
    return options;
};
const defaultCacheBuilder = () => {
    return async (options) => {
        switch (options.type) {
            case 'redis': {
                return await redis.RedisCache.build(options);
            }
            default: {
                return await Promise.resolve(new local.LocalLRUCache(options));
            }
        }
    };
};
// Options without sensitive data
const redactOptions = (options) => ({
    ...options,
    cacheImplOptions: options.cacheImplOptions.type === 'redis'
        ? redis.redactOptions(options.cacheImplOptions)
        : local.redactOptions(options.cacheImplOptions),
});
exports.redactOptions = redactOptions;
class AdapterCache {
    constructor(context) {
        this.hashOptions = util_1.getHashOpts();
        if (!context?.cache?.instance)
            throw Error(`cache not initiated`);
        const { cache: options, cache: { instance: cache }, } = context;
        this.options = options;
        this.cache = cache;
    }
    getKey(data) {
        return `${this.options.key.group}:${util_1.hash(data, this.hashOptions)}`;
    }
    getCoalescingKey(key) {
        return `inFlight:${key}`;
    }
    async setInFlightMarker(key, maxAge) {
        if (!this.options.requestCoalescing.enabled)
            return;
        await this.cache.setFlightMarker(key, maxAge);
        external_adapter_1.logger.debug(`Request coalescing: SET ${key}`);
    }
    async delInFlightMarker(key) {
        if (!this.options.requestCoalescing.enabled)
            return;
        await this.cache.del(key);
        external_adapter_1.logger.debug(`Request coalescing: DEL ${key}`);
    }
    getWithCoalescing(key) {
        return util_1.getWithCoalescing({
            get: async (retryCount) => {
                const entry = await this.cache.getResponse(key);
                if (entry)
                    external_adapter_1.logger.debug(`Request coalescing: GET on retry #${retryCount}`);
                return entry;
            },
            isInFlight: async (retryCount) => {
                if (retryCount === 1 && this.options.requestCoalescing.entropyMax) {
                    // Add some entropy here because of possible scenario where the key won't be set before multiple
                    // other instances in a burst request try to access the coalescing key.
                    const randomMs = Math.random() * this.options.requestCoalescing.entropyMax;
                    await util_1.delay(randomMs);
                }
                const inFlight = await this.cache.getFlightMarker(this.getCoalescingKey(key));
                external_adapter_1.logger.debug(`Request coalescing: CHECK inFlight:${inFlight} on retry #${retryCount}`);
                return inFlight;
            },
            retries: this.options.requestCoalescing.maxRetries,
            interval: (retryCount) => util_1.exponentialBackOffMs(retryCount, this.options.requestCoalescing.interval, this.options.requestCoalescing.intervalMax, this.options.requestCoalescing.intervalCoefficient),
        });
    }
    async getResultForRequest(adapterRequest) {
        const key = this.getKey(adapterRequest);
        const observe = metrics.beginObserveCacheMetrics({
            isFromWs: !!adapterRequest.debug?.ws,
            participantId: key,
            feedId: adapterRequest.metricsMeta?.feedId || 'N/A',
        });
        const cachedAdapterResponse = this.options.requestCoalescing.enabled
            ? await this.getWithCoalescing(key)
            : await this.cache.getResponse(key);
        if (cachedAdapterResponse) {
            const maxAgeOverride = ttl_1.getMaxAgeOverride(adapterRequest);
            if (adapterRequest?.debug?.warmer)
                external_adapter_1.logger.trace(`Cache: SKIP(Cache Warmer middleware)`);
            else if (adapterRequest?.debug?.ws)
                external_adapter_1.logger.trace(`Cache: SKIP(Websockets middleware)`);
            else if (maxAgeOverride && maxAgeOverride < 0)
                external_adapter_1.logger.trace(`Cache: SKIP(maxAge < 0)`);
            else {
                external_adapter_1.logger.trace(`Cache: GET ${key}`, cachedAdapterResponse);
                const ttl = await this.cache.ttl(key);
                // TODO: isnt this a bug? cachedAdapterResponse.maxAge will be different
                // if the above conditional gets executed!
                const staleness = (cachedAdapterResponse.maxAge - ttl) / 1000;
                const debug = {
                    ...cachedAdapterResponse?.debug,
                    cacheHit: true,
                    staleness,
                    performance: observe.stalenessAndExecutionTime(true, staleness),
                    providerCost: 0,
                };
                // we should be smarter about this in the future
                // and allow path configuration if result is not a number or string
                observe.cacheGet({ value: cachedAdapterResponse.result });
                const response = {
                    jobRunID: adapterRequest.id,
                    ...cachedAdapterResponse,
                    debug,
                };
                return response;
            }
        }
        return undefined;
    }
}
exports.AdapterCache = AdapterCache;
const withCache = (rateLimit) => async (execute, context) => {
    // If disabled noop
    if (!context?.cache?.instance)
        return (data) => execute(data, context);
    const adapterCache = new AdapterCache(context);
    const { cache: options, cache: { instance: cache }, } = context;
    return async (adapterRequest) => {
        const key = adapterCache.getKey(adapterRequest);
        const coalescingKey = adapterCache.getCoalescingKey(key);
        const observe = metrics.beginObserveCacheMetrics({
            isFromWs: !!adapterRequest.debug?.ws,
            participantId: key,
            feedId: adapterRequest.metricsMeta?.feedId || 'N/A',
        });
        try {
            const cachedAdapterResponse = await adapterCache.getResultForRequest(adapterRequest);
            if (cachedAdapterResponse)
                return cachedAdapterResponse;
        }
        catch (error) {
            external_adapter_1.logger.warn(`Cache middleware error! Passing through. `, error);
            return await execute(adapterRequest, context);
        }
        const maxAge = ttl_1.getTTL(adapterRequest, options);
        try {
            // Initiate request coalescing by adding the in-flight mark
            await adapterCache.setInFlightMarker(coalescingKey, maxAge);
        }
        catch (error) {
            external_adapter_1.logger.warn(`Cache middleware error! Passing through. `, error);
            return await execute(adapterRequest, context);
        }
        const burstRateLimit = burst_limit_1.withBurstLimit(rateLimit);
        const executeWithBackoff = await burstRateLimit(execute, context);
        const result = await executeWithBackoff(adapterRequest, context);
        try {
            // Add successful result to cache
            const _cacheOnSuccess = async ({ statusCode, data, result, debug, }) => {
                if (statusCode === 200) {
                    const debugBatchablePropertyPath = debug
                        ? { batchablePropertyPath: debug.batchablePropertyPath }
                        : {};
                    const entry = {
                        statusCode,
                        data,
                        result,
                        maxAge,
                        debug: debugBatchablePropertyPath,
                    };
                    // we should observe non-200 entries too
                    await cache.setResponse(key, entry, maxAge);
                    observe.cacheSet({ statusCode, maxAge });
                    external_adapter_1.logger.trace(`Cache: SET ${key}`, entry);
                    // Individually cache batch requests
                    if (data?.results) {
                        for (const batchParticipant of Object.values(data.results)) {
                            const [request, result] = batchParticipant;
                            const keyBatchParticipant = adapterCache.getKey(request);
                            const debugBatchablePropertyPath = debug
                                ? { batchablePropertyPath: debug.batchablePropertyPath }
                                : {};
                            const entryBatchParticipant = {
                                statusCode,
                                data: { result },
                                result,
                                maxAge,
                                debug: debugBatchablePropertyPath,
                            };
                            await cache.setResponse(keyBatchParticipant, entryBatchParticipant, maxAge);
                            external_adapter_1.logger.trace(`Cache Split Batch: SET ${keyBatchParticipant}`, entryBatchParticipant);
                        }
                    }
                }
                // Notify pending requests by removing the in-flight mark
                await adapterCache.delInFlightMarker(coalescingKey);
            };
            await _cacheOnSuccess(result);
            const debug = {
                staleness: 0,
                performance: observe.stalenessAndExecutionTime(false, 0),
                providerCost: result.data.cost || 1,
            };
            return { ...result, debug: { ...debug, ...result.debug } };
        }
        catch (error) {
            return result;
        }
    };
};
exports.withCache = withCache;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL2NhY2hlL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFDQSwwREFBNEM7QUFHNUMsZ0RBQStDO0FBQy9DLGtDQVFnQjtBQUNoQiwrQkFBaUQ7QUFDakQsdURBQWdDO0FBRWhDLDJEQUFvQztBQUNwQyx1REFBZ0M7QUFHaEMsTUFBTSxHQUFHLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQTtBQUVWLFFBQUEscUJBQXFCLEdBQUcsSUFBSSxDQUFBO0FBQ3pDLE1BQU0sa0JBQWtCLEdBQUcsT0FBTyxDQUFBO0FBQ2xDLE1BQU0sdUJBQXVCLEdBQUcsV0FBSSxFQUFFLENBQUE7QUFDdEMscUJBQXFCO0FBQ3JCLE1BQU0sbUJBQW1CLEdBQUcsR0FBRyxDQUFBO0FBQy9CLE1BQU0sdUJBQXVCLEdBQUcsSUFBSSxDQUFBO0FBQ3BDLE1BQU0sK0JBQStCLEdBQUcsQ0FBQyxDQUFBO0FBQ3pDLE1BQU0sc0JBQXNCLEdBQUcsQ0FBQyxDQUFBO0FBQ2hDLE1BQU0sc0JBQXNCLEdBQUcsQ0FBQyxDQUFBO0FBRW5CLFFBQUEsV0FBVyxHQUFHLElBQUksR0FBRyxFQUFFLEdBQUcsR0FBRyxDQUFBLENBQUMsYUFBYTtBQXVCakQsTUFBTSxjQUFjLEdBQUcsR0FBaUIsRUFBRTtJQUMvQyxPQUFPO1FBQ0wsT0FBTyxFQUFFLGdCQUFTLENBQUMsR0FBRyxDQUFDLGFBQWEsSUFBSSw2QkFBcUIsQ0FBQztRQUM5RCxnQkFBZ0IsRUFBRSx1QkFBdUIsRUFBRTtRQUMzQyxZQUFZLEVBQUUsbUJBQW1CLEVBQUU7UUFDbkMsR0FBRyxFQUFFO1lBQ0gsS0FBSyxFQUFFLEdBQUcsQ0FBQyxlQUFlLElBQUksdUJBQXVCO1NBQ3REO1FBQ0QscUJBQXFCO1FBQ3JCLGlCQUFpQixFQUFFO1lBQ2pCLE9BQU8sRUFBRSxnQkFBUyxDQUFDLEdBQUcsQ0FBQywwQkFBMEIsQ0FBQztZQUNs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TUFBTSxDQUFDLENBQUE7NEJBQzNFLHlCQUFNLENBQUMsS0FBSyxDQUFDLDBCQUEwQixtQkFBbUIsRUFBRSxFQUFFLHFCQUFxQixDQUFDLENBQUE7eUJBQ3JGO3FCQUNGO2lCQUNGO2dCQUNELHlEQUF5RDtnQkFDekQsTUFBTSxZQUFZLENBQUMsaUJBQWlCLENBQUMsYUFBYSxDQUFDLENBQUE7WUFDckQsQ0FBQyxDQUFBO1lBQ0QsTUFBTSxlQUFlLENBQUMsTUFBTSxDQUFDLENBQUE7WUFFN0IsTUFBTSxLQUFLLEdBQUc7Z0JBQ1osU0FBUyxFQUFFLENBQUM7Z0JBQ1osV0FBVyxFQUFFLE9BQU8sQ0FBQyx5QkFBeUIsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO2dCQUN4RCxZQUFZLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQzthQUNwQyxDQUFBO1lBQ0QsT0FBTyxFQUFFLEdBQUcsTUFBTSxFQUFFLEtBQUssRUFBRSxFQUFFLEdBQUcsS0FBSyxFQUFFLEdBQUcsTUFBTSxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUE7U0FDM0Q7UUFBQyxPQUFPLEtBQUssRUFBRTtZQUNkLE9BQU8sTUFBTSxDQUFBO1NBQ2Q7SUFDSCxDQUFDLENBQUE7QUFDSCxDQUFDLENBQUE7QUF4R1UsUUFBQSxTQUFTLGFBd0duQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFkYXB0ZXJDb250ZXh0LCBBZGFwdGVyUmVxdWVzdCwgQWRhcHRlclJlc3BvbnNlLCBNaWRkbGV3YXJlIH0gZnJvbSAnQGNoYWlubGluay90eXBlcydcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL2V4dGVybmFsLWFkYXB0ZXInXG5pbXBvcnQgeyBTdG9yZSB9IGZyb20gJ3JlZHV4J1xuaW1wb3J0IHsgcmVkdWNlciB9IGZyb20gJy4uL2J1cnN0LWxpbWl0J1xuaW1wb3J0IHsgd2l0aEJ1cnN0TGltaXQgfSBmcm9tICcuLi9idXJzdC1saW1pdCdcbmltcG9ydCB7XG4gIGRlbGF5LFxuICBleHBvbmVudGlhbEJhY2tPZmZNcyxcbiAgZ2V0SGFzaE9wdHMsXG4gIGdldFdpdGhDb2FsZXNjaW5nLFxuICBwYXJzZUJvb2wsXG4gIHV1aWQsXG4gIGhhc2gsXG59IGZyb20gJy4uL3V0aWwnXG5pbXBvcnQgeyBnZXRNYXhBZ2VPdmVycmlkZSwgZ2V0VFRMIH0gZnJvbSAnLi90dGwnXG5pbXBvcnQgKiBhcyBsb2NhbCBmcm9tICcuL2xvY2FsJ1xuaW1wb3J0IHsgTG9jYWxPcHRpb25zIH0gZnJvbSAnLi9sb2NhbCdcbmltcG9ydCAqIGFzIG1ldHJpY3MgZnJvbSAnLi9tZXRyaWNzJ1xuaW1wb3J0ICogYXMgcmVkaXMgZnJvbSAnLi9yZWRpcydcbmltcG9ydCB7IENhY2hlRW50cnkgfSBmcm9tICcuL3R5cGVzJ1xuXG5jb25zdCBlbnYgPSBwcm9jZXNzLmVudlxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9DQUNIRV9FTkFCTEVEID0gdHJ1ZVxuY29uc3QgREVGQVVMVF9DQUNIRV9UWVBFID0gJ2xvY2FsJ1xuY29uc3QgREVGQVVMVF9DQUNIRV9LRVlfR1JPVVAgPSB1dWlkKClcbi8vIFJlcXVlc3QgY29hbGVzY2luZ1xuY29uc3QgREVGQVVMVF9SQ19JTlRFUlZBTCA9IDEwMFxuY29uc3QgREVGQVVMVF9SQ19JTlRFUlZBTF9NQVggPSAxMDAwXG5jb25zdCBERUZBVUxUX1JDX0lOVEVSVkFMX0NPRUZGSUNJRU5UID0gMlxuY29uc3QgREVGQVVMVF9SQ19FTlRST1BZX01BWCA9IDBcbmNvbnN0IERFRkFVTFRfUkNfTUFYX1JFVFJJRVMgPSA1XG5cbmV4cG9ydCBjb25zdCBNSU5JTVVNX0FHRSA9IDEwMDAgKiA2MCAqIDAuNSAvLyAzMCBzZWNvbmRzXG5cbmV4cG9ydCB0eXBlIENhY2hlID0gcmVkaXMuUmVkaXNDYWNoZSB8IGxvY2FsLkxvY2FsTFJVQ2FjaGVcblxuZXhwb3J0IGludGVyZmFjZSBDYWNoZU9wdGlvbnMge1xuICBpbnN0YW5jZT86IENhY2hlXG4gIGVuYWJsZWQ6IGJvb2xlYW5cbiAgY2FjaGVJbXBsT3B0aW9uczogbG9jYWwuTG9jYWxPcHRpb25zIHwgcmVkaXMuUmVkaXNPcHRpb25zXG4gIGNhY2hlQnVpbGRlcjogKG9wdGlvbnM6IENhY2hlSW1wbE9wdGlvbnMpID0+IFByb21pc2U8cmVkaXMuUmVkaXNDYWNoZSB8IGxvY2FsLkxvY2FsTFJVQ2FjaGU+XG4gIGtleToge1xuICAgIGdyb3VwOiBzdHJpbmdcbiAgfVxuICByZXF1ZXN0Q29hbGVzY2luZzoge1xuICAgIGVuYWJsZWQ6IGJvb2xlYW5cbiAgICBpbnRlcnZhbDogbnVtYmVyXG4gICAgaW50ZXJ2YWxNYXg6IG51bWJlclxuICAgIGludGVydmFsQ29lZmZpY2llbnQ6IG51bWJlclxuICAgIGVudHJvcHlNYXg6IG51bWJlclxuICAgIG1heFJldHJpZXM6IG51bWJlclxuICB9XG4gIG1pbmltdW1BZ2U6IG51bWJlclxufVxuXG5leHBvcnQgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSAoKTogQ2FjaGVPcHRpb25zID0+IHtcbiAgcmV0dXJuIHtcbiAgICBlbmFibGVkOiBwYXJzZUJvb2woZW52LkNBQ0hFX0VOQUJMRUQgPz8gREVGQVVMVF9DQUNIRV9FTkFCTEVEKSxcbiAgICBjYWNoZUltcGxPcHRpb25zOiBkZWZhdWx0Q2FjaGVJbXBsT3B0aW9ucygpLFxuICAgIGNhY2hlQnVpbGRlcjogZGVmYXVsdENhY2hlQnVpbGRlcigpLFxuICAgIGtleToge1xuICAgICAgZ3JvdXA6IGVudi5DQUNIRV9LRVlfR1JPVVAgfHwgREVGQVVMVF9DQUNIRV9LRVlfR1JPVVAsXG4gICAgfSxcbiAgICAvLyBSZXF1ZXN0IGNvYWxlc2NpbmdcbiAgICByZXF1ZXN0Q29hbGVzY2luZzoge1xuICAgICAgZW5hYmxlZDogcGFyc2VCb29sKGVudi5SRVFVRVNUX0NPQUxFU0NJTkdfRU5BQkxFRCksXG4gICAgICAvLyBDYXBwZWQgbGluZWFyIGJhY2stb2ZmOiAxMDAsIDIwMCwgNDAwLCA4MDAsIDEwMDAuLlxuICAgICAgaW50ZXJ2YWw6IE51bWJlcihlbnYuUkVRVUVTVF9DT0FMRVNDSU5HX0lOVEVSVkFMKSB8fCBERUZBVUxUX1JDX0lOVEVSVkFMLFxuICAgICAgaW50ZXJ2YWxNYXg6IE51bWJlcihlbnYuUkVRVUVTVF9DT0FMRVNDSU5HX0lOVEVSVkFMX01BWCkgfHwgREVGQVVMVF9SQ19JTlRFUlZBTF9NQVgsXG4gICAgICBpbnRlcnZhbENvZWZmaWNpZW50OlxuICAgICAgICBOdW1iZXIoZW52LlJFUVVFU1RfQ09BTEVTQ0lOR19JTlRFUlZBTF9DT0VGRklDSUVOVCkgfHwgREVGQVVMVF9SQ19JTlRFUlZBTF9DT0VGRklDSUVOVCxcbiAgICAgIC8vIEFkZCBlbnRyb3B5IHRvIGFic29yYiBidXJzdHNcbiAgICAgIGVudHJvcHlNYXg6IE51bWJlcihlbnYuUkVRVUVTVF9DT0FMRVNDSU5HX0VOVFJPUFlfTUFYKSB8fCBERUZBVUxUX1JDX0VOVFJPUFlfTUFYLFxuICAgICAgbWF4UmV0cmllczogTnVtYmVyKGVudi5SRVFVRVNUX0NPQUxFU0NJTkdfTUFYX1JFVFJJRVMpIHx8IERFRkFVTFRfUkNfTUFYX1JFVFJJRVMsXG4gICAgfSxcbiAgICBtaW5pbXVtQWdlOiBOdW1iZXIoZW52LkNBQ0hFX01JTl9BR0UpIHx8IE1JTklNVU1fQUdFLFxuICB9XG59XG5cbmV4cG9ydCB0eXBlIENhY2hlSW1wbE9wdGlvbnMgPSBMb2NhbE9wdGlvbnMgfCByZWRpcy5SZWRpc09wdGlvbnNcbmNvbnN0IGRlZmF1bHRDYWNoZUltcGxPcHRpb25zID0gKCk6IENhY2hlSW1wbE9wdGlvbnMgPT4ge1xuICBjb25zdCB0eXBlID0gZW52LkNBQ0hFX1RZUEUgfHwgREVGQVVMVF9DQUNIRV9UWVBFXG4gIGNvbnN0IG9wdGlvbnMgPSB0eXBlID09PSAncmVkaXMnID8gcmVkaXMuZGVmYXVsdE9wdGlvbnMoKSA6IGxvY2FsLmRlZmF1bHRPcHRpb25zKClcbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuY29uc3QgZGVmYXVsdENhY2hlQnVpbGRlciA9ICgpID0+IHtcbiAgcmV0dXJuIGFzeW5jIChvcHRpb25zOiBDYWNoZUltcGxPcHRpb25zKSA9PiB7XG4gICAgc3dpdGNoIChvcHRpb25zLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3JlZGlzJzoge1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVkaXMuUmVkaXNDYWNoZS5idWlsZChvcHRpb25zIGFzIHJlZGlzLlJlZGlzT3B0aW9ucylcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKG5ldyBsb2NhbC5Mb2NhbExSVUNhY2hlKG9wdGlvbnMpKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBPcHRpb25zIHdpdGhvdXQgc2Vuc2l0aXZlIGRhdGFcbmV4cG9ydCBjb25zdCByZWRhY3RPcHRpb25zID0gKG9wdGlvbnM6IENhY2hlT3B0aW9ucyk6IENhY2hlT3B0aW9ucyA9PiAoe1xuICAuLi5vcHRpb25zLFxuICBjYWNoZUltcGxPcHRpb25zOlxuICAgIG9wdGlvbnMuY2FjaGVJbXBsT3B0aW9ucy50eXBlID09PSAncmVkaXMnXG4gICAgICA/IHJlZGlzLnJlZGFjdE9wdGlvbnMob3B0aW9ucy5jYWNoZUltcGxPcHRpb25zIGFzIHJlZGlzLlJlZGlzT3B0aW9ucylcbiAgICAgIDogbG9jYWwucmVkYWN0T3B0aW9ucyhvcHRpb25zLmNhY2hlSW1wbE9wdGlvbnMpLFxufSlcblxuZXhwb3J0IGNsYXNzIEFkYXB0ZXJDYWNoZSB7XG4gIHByaXZhdGUgcmVhZG9ubHkgb3B0aW9uczogQ2FjaGVPcHRpb25zXG4gIHByaXZhdGUgY2FjaGU6IENhY2hlXG4gIHByaXZhdGUgaGFzaE9wdGlvbnMgPSBnZXRIYXNoT3B0cygpXG5cbiAgY29uc3RydWN0b3IoY29udGV4dDogQWRhcHRlckNvbnRleHQpIHtcbiAgICBpZiAoIWNvbnRleHQ/LmNhY2hlPy5pbnN0YW5jZSkgdGhyb3cgRXJyb3IoYGNhY2hlIG5vdCBpbml0aWF0ZWRgKVxuXG4gICAgY29uc3Qge1xuICAgICAgY2FjaGU6IG9wdGlvbnMsXG4gICAgICBjYWNoZTogeyBpbnN0YW5jZTogY2FjaGUgfSxcbiAgICB9ID0gY29udGV4dFxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLmNhY2hlID0gY2FjaGVcbiAgfVxuXG4gIHB1YmxpYyBnZXRLZXkoZGF0YTogQWRhcHRlclJlcXVlc3QpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHt0aGlzLm9wdGlvbnMua2V5Lmdyb3VwfToke2hhc2goZGF0YSwgdGhpcy5oYXNoT3B0aW9ucyl9YFxuICB9XG5cbiAgcHVibGljIGdldENvYWxlc2NpbmdLZXkoa2V5OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBgaW5GbGlnaHQ6JHtrZXl9YFxuICB9XG5cbiAgcHVibGljIGFzeW5jIHNldEluRmxpZ2h0TWFya2VyKGtleTogc3RyaW5nLCBtYXhBZ2U6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghdGhpcy5vcHRpb25zLnJlcXVlc3RDb2FsZXNjaW5nLmVuYWJsZWQpIHJldHVyblxuICAgIGF3YWl0IHRoaXMuY2FjaGUuc2V0RmxpZ2h0TWFya2VyKGtleSwgbWF4QWdlKVxuICAgIGxvZ2dlci5kZWJ1ZyhgUmVxdWVzdCBjb2FsZXNjaW5nOiBTRVQgJHtrZXl9YClcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBkZWxJbkZsaWdodE1hcmtlcihrZXk6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghdGhpcy5vcHRpb25zLnJlcXVlc3RDb2FsZXNjaW5nLmVuYWJsZWQpIHJldHVyblxuICAgIGF3YWl0IHRoaXMuY2FjaGUuZGVsKGtleSlcbiAgICBsb2dnZXIuZGVidWcoYFJlcXVlc3QgY29hbGVzY2luZzogREVMICR7a2V5fWApXG4gIH1cblxuICBwdWJsaWMgZ2V0V2l0aENvYWxlc2Npbmcoa2V5OiBzdHJpbmcpOiBQcm9taXNlPHVuZGVmaW5lZCB8IENhY2hlRW50cnk+IHtcbiAgICByZXR1cm4gZ2V0V2l0aENvYWxlc2Npbmcoe1xuICAgICAgZ2V0OiBhc3luYyAocmV0cnlDb3VudDogbnVtYmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gYXdhaXQgdGhpcy5jYWNoZS5nZXRSZXNwb25zZShrZXkpXG4gICAgICAgIGlmIChlbnRyeSkgbG9nZ2VyLmRlYnVnKGBSZXF1ZXN0IGNvYWxlc2Npbmc6IEdFVCBvbiByZXRyeSAjJHtyZXRyeUNvdW50fWApXG4gICAgICAgIHJldHVybiBlbnRyeVxuICAgICAgfSxcbiAgICAgIGlzSW5GbGlnaHQ6IGFzeW5jIChyZXRyeUNvdW50OiBudW1iZXIpID0+IHtcbiAgICAgICAgaWYgKHJldHJ5Q291bnQgPT09IDEgJiYgdGhpcy5vcHRpb25zLnJlcXVlc3RDb2FsZXNjaW5nLmVudHJvcHlNYXgpIHtcbiAgICAgICAgICAvLyBBZGQgc29tZSBlbnRyb3B5IGhlcmUgYmVjYXVzZSBvZiBwb3NzaWJsZSBzY2VuYXJpbyB3aGVyZSB0aGUga2V5IHdvbid0IGJlIHNldCBiZWZvcmUgbXVsdGlwbGVcbiAgICAgICAgICAvLyBvdGhlciBpbnN0YW5jZXMgaW4gYSBidXJzdCByZXF1ZXN0IHRyeSB0byBhY2Nlc3MgdGhlIGNvYWxlc2Npbmcga2V5LlxuICAgICAgICAgIGNvbnN0IHJhbmRvbU1zID0gTWF0aC5yYW5kb20oKSAqIHRoaXMub3B0aW9ucy5yZXF1ZXN0Q29hbGVzY2luZy5lbnRyb3B5TWF4XG4gICAgICAgICAgYXdhaXQgZGVsYXkocmFuZG9tTXMpXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5GbGlnaHQgPSBhd2FpdCB0aGlzLmNhY2hlLmdldEZsaWdodE1hcmtlcih0aGlzLmdldENvYWxlc2NpbmdLZXkoa2V5KSlcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBSZXF1ZXN0IGNvYWxlc2Npbmc6IENIRUNLIGluRmxpZ2h0OiR7aW5GbGlnaHR9IG9uIHJldHJ5ICMke3JldHJ5Q291bnR9YClcbiAgICAgICAgcmV0dXJuIGluRmxpZ2h0XG4gICAgICB9LFxuICAgICAgcmV0cmllczogdGhpcy5vcHRpb25zLnJlcXVlc3RDb2FsZXNjaW5nLm1heFJldHJpZXMsXG4gICAgICBpbnRlcnZhbDogKHJldHJ5Q291bnQ6IG51bWJlcikgPT5cbiAgICAgICAgZXhwb25lbnRpYWxCYWNrT2ZmTXMoXG4gICAgICAgICAgcmV0cnlDb3VudCxcbiAgICAgICAgICB0aGlzLm9wdGlvbnMucmVxdWVzdENvYWxlc2NpbmcuaW50ZXJ2YWwsXG4gICAgICAgICAgdGhpcy5vcHRpb25zLnJlcXVlc3RDb2FsZXNjaW5nLmludGVydmFsTWF4LFxuICAgICAgICAgIHRoaXMub3B0aW9ucy5yZXF1ZXN0Q29hbGVzY2luZy5pbnRlcnZhbENvZWZmaWNpZW50LFxuICAgICAgICApLFxuICAgIH0pXG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0UmVzdWx0Rm9yUmVxdWVzdChcbiAgICBhZGFwdGVyUmVxdWVzdDogQWRhcHRlclJlcXVlc3QsXG4gICk6IFByb21pc2U8QWRhcHRlclJlc3BvbnNlIHwgdW5kZWZpbmVkPiB7XG4gICAgY29uc3Qga2V5ID0gdGhpcy5nZXRLZXkoYWRhcHRlclJlcXVlc3QpXG4gICAgY29uc3Qgb2JzZXJ2ZSA9IG1ldHJpY3MuYmVnaW5PYnNlcnZlQ2FjaGVNZXRyaWNzKHtcbiAgICAgIGlzRnJvbVdzOiAhIWFkYXB0ZXJSZXF1ZXN0LmRlYnVnPy53cyxcbiAgICAgIHBhcnRpY2lwYW50SWQ6IGtleSxcbiAgICAgIGZlZWRJZDogYWRhcHRlclJlcXVlc3QubWV0cmljc01ldGE/LmZlZWRJZCB8fCAnTi9BJyxcbiAgICB9KVxuXG4gICAgY29uc3QgY2FjaGVkQWRhcHRlclJlc3BvbnNlID0gdGhpcy5vcHRpb25zLnJlcXVlc3RDb2FsZXNjaW5nLmVuYWJsZWRcbiAgICAgID8gYXdhaXQgdGhpcy5nZXRXaXRoQ29hbGVzY2luZyhrZXkpXG4gICAgICA6IGF3YWl0IHRoaXMuY2FjaGUuZ2V0UmVzcG9uc2Uoa2V5KVxuXG4gICAgaWYgKGNhY2hlZEFkYXB0ZXJSZXNwb25zZSkge1xuICAgICAgY29uc3QgbWF4QWdlT3ZlcnJpZGUgPSBnZXRNYXhBZ2VPdmVycmlkZShhZGFwdGVyUmVxdWVzdClcbiAgICAgIGlmIChhZGFwdGVyUmVxdWVzdD8uZGVidWc/Lndhcm1lcikgbG9nZ2VyLnRyYWNlKGBDYWNoZTogU0tJUChDYWNoZSBXYXJtZXIgbWlkZGxld2FyZSlgKVxuICAgICAgZWxzZSBpZiAoYWRhcHRlclJlcXVlc3Q/LmRlYnVnPy53cykgbG9nZ2VyLnRyYWNlKGBDYWNoZTogU0tJUChXZWJzb2NrZXRzIG1pZGRsZXdhcmUpYClcbiAgICAgIGVsc2UgaWYgKG1heEFnZU92ZXJyaWRlICYmIG1heEFnZU92ZXJyaWRlIDwgMCkgbG9nZ2VyLnRyYWNlKGBDYWNoZTogU0tJUChtYXhBZ2UgPCAwKWApXG4gICAgICBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLnRyYWNlKGBDYWNoZTogR0VUICR7a2V5fWAsIGNhY2hlZEFkYXB0ZXJSZXNwb25zZSlcbiAgICAgICAgY29uc3QgdHRsID0gYXdhaXQgdGhpcy5jYWNoZS50dGwoa2V5KVxuICAgICAgICAvLyBUT0RPOiBpc250IHRoaXMgYSBidWc/IGNhY2hlZEFkYXB0ZXJSZXNwb25zZS5tYXhBZ2Ugd2lsbCBiZSBkaWZmZXJlbnRcbiAgICAgICAgLy8gaWYgdGhlIGFib3ZlIGNvbmRpdGlvbmFsIGdldHMgZXhlY3V0ZWQhXG4gICAgICAgIGNvbnN0IHN0YWxlbmVzcyA9IChjYWNoZWRBZGFwdGVyUmVzcG9uc2UubWF4QWdlIC0gdHRsKSAvIDEwMDBcbiAgICAgICAgY29uc3QgZGVidWcgPSB7XG4gICAgICAgICAgLi4uY2FjaGVkQWRhcHRlclJlc3BvbnNlPy5kZWJ1ZyxcbiAgICAgICAgICBjYWNoZUhpdDogdHJ1ZSxcbiAgICAgICAgICBzdGFsZW5lc3MsXG4gICAgICAgICAgcGVyZm9ybWFuY2U6IG9ic2VydmUuc3RhbGVuZXNzQW5kRXhlY3V0aW9uVGltZSh0cnVlLCBzdGFsZW5lc3MpLFxuICAgICAgICAgIHByb3ZpZGVyQ29zdDogMCxcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlIHNob3VsZCBiZSBzbWFydGVyIGFib3V0IHRoaXMgaW4gdGhlIGZ1dHVyZVxuICAgICAgICAvLyBhbmQgYWxsb3cgcGF0aCBjb25maWd1cmF0aW9uIGlmIHJlc3VsdCBpcyBub3QgYSBudW1iZXIgb3Igc3RyaW5nXG4gICAgICAgIG9ic2VydmUuY2FjaGVHZXQoeyB2YWx1ZTogY2FjaGVkQWRhcHRlclJlc3BvbnNlLnJlc3VsdCB9KVxuICAgICAgICBjb25zdCByZXNwb25zZTogQWRhcHRlclJlc3BvbnNlID0ge1xuICAgICAgICAgIGpvYlJ1bklEOiBhZGFwdGVyUmVxdWVzdC5pZCxcbiAgICAgICAgICAuLi5jYWNoZWRBZGFwdGVyUmVzcG9uc2UsXG4gICAgICAgICAgZGVidWcsXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzcG9uc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHdpdGhDYWNoZSA9XG4gIChyYXRlTGltaXQ/OiBTdG9yZTxyZWR1Y2VyLkJ1cnN0TGltaXRTdGF0ZT4pOiBNaWRkbGV3YXJlID0+XG4gIGFzeW5jIChleGVjdXRlLCBjb250ZXh0OiBBZGFwdGVyQ29udGV4dCkgPT4ge1xuICAgIC8vIElmIGRpc2FibGVkIG5vb3BcbiAgICBpZiAoIWNvbnRleHQ/LmNhY2hlPy5pbnN0YW5jZSkgcmV0dXJuIChkYXRhOiBBZGFwdGVyUmVxdWVzdCkgPT4gZXhlY3V0ZShkYXRhLCBjb250ZXh0KVxuXG4gICAgY29uc3QgYWRhcHRlckNhY2hlID0gbmV3IEFkYXB0ZXJDYWNoZShjb250ZXh0KVxuXG4gICAgY29uc3Qge1xuICAgICAgY2FjaGU6IG9wdGlvbnMsXG4gICAgICBjYWNoZTogeyBpbnN0YW5jZTogY2FjaGUgfSxcbiAgICB9ID0gY29udGV4dFxuXG4gICAgcmV0dXJuIGFzeW5jIChhZGFwdGVyUmVxdWVzdCkgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gYWRhcHRlckNhY2hlLmdldEtleShhZGFwdGVyUmVxdWVzdClcbiAgICAgIGNvbnN0IGNvYWxlc2NpbmdLZXkgPSBhZGFwdGVyQ2FjaGUuZ2V0Q29hbGVzY2luZ0tleShrZXkpXG4gICAgICBjb25zdCBvYnNlcnZlID0gbWV0cmljcy5iZWdpbk9ic2VydmVDYWNoZU1ldHJpY3Moe1xuICAgICAgICBpc0Zyb21XczogISFhZGFwdGVyUmVxdWVzdC5kZWJ1Zz8ud3MsXG4gICAgICAgIHBhcnRpY2lwYW50SWQ6IGtleSxcbiAgICAgICAgZmVlZElkOiBhZGFwdGVyUmVxdWVzdC5tZXRyaWNzTWV0YT8uZmVlZElkIHx8ICdOL0EnLFxuICAgICAgfSlcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2FjaGVkQWRhcHRlclJlc3BvbnNlID0gYXdhaXQgYWRhcHRlckNhY2hlLmdldFJlc3VsdEZvclJlcXVlc3QoYWRhcHRlclJlcXVlc3QpXG4gICAgICAgIGlmIChjYWNoZWRBZGFwdGVyUmVzcG9uc2UpIHJldHVybiBjYWNoZWRBZGFwdGVyUmVzcG9uc2VcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKGBDYWNoZSBtaWRkbGV3YXJlIGVycm9yISBQYXNzaW5nIHRocm91Z2guIGAsIGVycm9yKVxuICAgICAgICByZXR1cm4gYXdhaXQgZXhlY3V0ZShhZGFwdGVyUmVxdWVzdCwgY29udGV4dClcbiAgICAgIH1cblxuICAgICAgY29uc3QgbWF4QWdlID0gZ2V0VFRMKGFkYXB0ZXJSZXF1ZXN0LCBvcHRpb25zKVxuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBJbml0aWF0ZSByZXF1ZXN0IGNvYWxlc2NpbmcgYnkgYWRkaW5nIHRoZSBpbi1mbGlnaHQgbWFya1xuICAgICAgICBhd2FpdCBhZGFwdGVyQ2FjaGUuc2V0SW5GbGlnaHRNYXJrZXIoY29hbGVzY2luZ0tleSwgbWF4QWdlKVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oYENhY2hlIG1pZGRsZXdhcmUgZXJyb3IhIFBhc3NpbmcgdGhyb3VnaC4gYCwgZXJyb3IpXG4gICAgICAgIHJldHVybiBhd2FpdCBleGVjdXRlKGFkYXB0ZXJSZXF1ZXN0LCBjb250ZXh0KVxuICAgICAgfVxuXG4gICAgICBjb25zdCBidXJzdFJhdGVMaW1pdCA9IHdpdGhCdXJzdExpbWl0KHJhdGVMaW1pdClcbiAgICAgIGNvbnN0IGV4ZWN1dGVXaXRoQmFja29mZiA9IGF3YWl0IGJ1cnN0UmF0ZUxpbWl0KGV4ZWN1dGUsIGNvbnRleHQpXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBleGVjdXRlV2l0aEJhY2tvZmYoYWRhcHRlclJlcXVlc3QsIGNvbnRleHQpXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEFkZCBzdWNjZXNzZnVsIHJlc3VsdCB0byBjYWNoZVxuICAgICAgICBjb25zdCBfY2FjaGVPblN1Y2Nlc3MgPSBhc3luYyAoe1xuICAgICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgZGVidWcsXG4gICAgICAgIH06IFBpY2s8QWRhcHRlclJlc3BvbnNlLCAnc3RhdHVzQ29kZScgfCAnZGF0YScgfCAncmVzdWx0JyB8ICdkZWJ1Zyc+KSA9PiB7XG4gICAgICAgICAgaWYgKHN0YXR1c0NvZGUgPT09IDIwMCkge1xuICAgICAgICAgICAgY29uc3QgZGVidWdCYXRjaGFibGVQcm9wZXJ0eVBhdGggPSBkZWJ1Z1xuICAgICAgICAgICAgICA/IHsgYmF0Y2hhYmxlUHJvcGVydHlQYXRoOiBkZWJ1Zy5iYXRjaGFibGVQcm9wZXJ0eVBhdGggfVxuICAgICAgICAgICAgICA6IHt9XG4gICAgICAgICAgICBjb25zdCBlbnRyeTogQ2FjaGVFbnRyeSA9IHtcbiAgICAgICAgICAgICAgc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgICAgICBtYXhBZ2UsXG4gICAgICAgICAgICAgIGRlYnVnOiBkZWJ1Z0JhdGNoYWJsZVByb3BlcnR5UGF0aCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdlIHNob3VsZCBvYnNlcnZlIG5vbi0yMDAgZW50cmllcyB0b29cbiAgICAgICAgICAgIGF3YWl0IGNhY2hlLnNldFJlc3BvbnNlKGtleSwgZW50cnksIG1heEFnZSlcbiAgICAgICAgICAgIG9ic2VydmUuY2FjaGVTZXQoeyBzdGF0dXNDb2RlLCBtYXhBZ2UgfSlcbiAgICAgICAgICAgIGxvZ2dlci50cmFjZShgQ2FjaGU6IFNFVCAke2tleX1gLCBlbnRyeSlcbiAgICAgICAgICAgIC8vIEluZGl2aWR1YWxseSBjYWNoZSBiYXRjaCByZXF1ZXN0c1xuICAgICAgICAgICAgaWYgKGRhdGE/LnJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBiYXRjaFBhcnRpY2lwYW50IG9mIE9iamVjdC52YWx1ZXM8W0FkYXB0ZXJSZXF1ZXN0LCBudW1iZXJdPihcbiAgICAgICAgICAgICAgICBkYXRhLnJlc3VsdHMsXG4gICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbcmVxdWVzdCwgcmVzdWx0XSA9IGJhdGNoUGFydGljaXBhbnRcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlCYXRjaFBhcnRpY2lwYW50ID0gYWRhcHRlckNhY2hlLmdldEtleShyZXF1ZXN0KVxuICAgICAgICAgICAgICAgIGNvbnN0IGRlYnVnQmF0Y2hhYmxlUHJvcGVydHlQYXRoID0gZGVidWdcbiAgICAgICAgICAgICAgICAgID8geyBiYXRjaGFibGVQcm9wZXJ0eVBhdGg6IGRlYnVnLmJhdGNoYWJsZVByb3BlcnR5UGF0aCB9XG4gICAgICAgICAgICAgICAgICA6IHt9XG4gICAgICAgICAgICAgICAgY29uc3QgZW50cnlCYXRjaFBhcnRpY2lwYW50ID0ge1xuICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgICAgIGRhdGE6IHsgcmVzdWx0IH0sXG4gICAgICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgICAgICBtYXhBZ2UsXG4gICAgICAgICAgICAgICAgICBkZWJ1ZzogZGVidWdCYXRjaGFibGVQcm9wZXJ0eVBhdGgsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF3YWl0IGNhY2hlLnNldFJlc3BvbnNlKGtleUJhdGNoUGFydGljaXBhbnQsIGVudHJ5QmF0Y2hQYXJ0aWNpcGFudCwgbWF4QWdlKVxuICAgICAgICAgICAgICAgIGxvZ2dlci50cmFjZShgQ2FjaGUgU3BsaXQgQmF0Y2g6IFNFVCAke2tleUJhdGNoUGFydGljaXBhbnR9YCwgZW50cnlCYXRjaFBhcnRpY2lwYW50KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE5vdGlmeSBwZW5kaW5nIHJlcXVlc3RzIGJ5IHJlbW92aW5nIHRoZSBpbi1mbGlnaHQgbWFya1xuICAgICAgICAgIGF3YWl0IGFkYXB0ZXJDYWNoZS5kZWxJbkZsaWdodE1hcmtlcihjb2FsZXNjaW5nS2V5KVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IF9jYWNoZU9uU3VjY2VzcyhyZXN1bHQpXG5cbiAgICAgICAgY29uc3QgZGVidWcgPSB7XG4gICAgICAgICAgc3RhbGVuZXNzOiAwLFxuICAgICAgICAgIHBlcmZvcm1hbmNlOiBvYnNlcnZlLnN0YWxlbmVzc0FuZEV4ZWN1dGlvblRpbWUoZmFsc2UsIDApLFxuICAgICAgICAgIHByb3ZpZGVyQ29zdDogcmVzdWx0LmRhdGEuY29zdCB8fCAxLFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IC4uLnJlc3VsdCwgZGVidWc6IHsgLi4uZGVidWcsIC4uLnJlc3VsdC5kZWJ1ZyB9IH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cbiAgICB9XG4gIH1cbiJdfQ==