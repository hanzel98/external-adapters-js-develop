"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.execute = exports.NAME = void 0;
const ea_bootstrap_1 = require("@chainlink/ea-bootstrap");
const ethers_1 = require("ethers");
exports.NAME = 'txsend';
const encode = (type, value) => {
    let retVal;
    switch (type) {
        case 'bytes32':
            retVal = ethers_1.ethers.utils.formatBytes32String(value);
            break;
        default:
            retVal = ethers_1.ethers.utils.defaultAbiCoder.encode([type], [value]);
            break;
    }
    return retVal.slice(2);
};
const customParams = {
    exAddr: true,
    funcId: false,
    dataType: false,
    result: false,
    dataToSend: false,
};
const execute = async (request, _, config) => {
    const provider = new ethers_1.ethers.providers.JsonRpcProvider(config.rpcUrl);
    const wallet = new ethers_1.ethers.Wallet(config.privateKey, provider);
    const validator = new ea_bootstrap_1.Validator(request, customParams);
    if (validator.error)
        throw validator.error;
    const getUint256 = '0xc2b12a73';
    const jobRunID = validator.validated.id;
    const externalAddress = validator.validated.data.exAddr;
    const functionId = validator.validated.data.funcId || getUint256;
    // Passing this optionally, in case the data is not encrypted from the previous step
    const dataType = validator.validated.data.dataType;
    // Prioritize data coming from a previous adapter (result),
    // but allow dataToSend to be used if specified
    const dataToSend = validator.validated.data.result || validator.validated.data.dataToSend || '';
    // Ensure we use only 4 bytes for the functionId
    let transactionData;
    if (dataType) {
        transactionData = functionId.substring(0, 10) + encode(dataType, dataToSend);
    }
    else {
        transactionData = functionId.substring(0, 10) + dataToSend;
    }
    const transaction = {
        to: externalAddress,
        data: transactionData,
    };
    try {
        const tx = await wallet.sendTransaction(transaction);
        return ea_bootstrap_1.Requester.success(jobRunID, {
            data: tx,
            status: 200,
        });
    }
    catch (e) {
        throw new ea_bootstrap_1.AdapterError({
            jobRunID,
            message: e,
            statusCode: 400,
        });
    }
};
exports.execute = execute;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHhzZW5kLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2VuZHBvaW50L3R4c2VuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSwwREFBNEU7QUFFNUUsbUNBQStCO0FBR2xCLFFBQUEsSUFBSSxHQUFHLFFBQVEsQ0FBQTtBQUU1QixNQUFNLE1BQU0sR0FBRyxDQUFDLElBQVMsRUFBRSxLQUFVLEVBQUUsRUFBRTtJQUN2QyxJQUFJLE1BQU0sQ0FBQTtJQUNWLFFBQVEsSUFBSSxFQUFFO1FBQ1osS0FBSyxTQUFTO1lBQ1osTUFBTSxHQUFHLGVBQU0sQ0FBQyxLQUFLLENBQUMsbUJBQW1CLENBQUMsS0FBSyxDQUFDLENBQUE7WUFDaEQsTUFBSztRQUNQO1lBQ0UsTUFBTSxHQUFHLGVBQU0sQ0FBQyxLQUFLLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQTtZQUM3RCxNQUFLO0tBQ1I7SUFDRCxPQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUE7QUFDeEIsQ0FBQyxDQUFBO0FBRUQsTUFBTSxZQUFZLEdBQUc7SUFDbkIsTUFBTSxFQUFFLElBQUk7SUFDWixNQUFNLEVBQUUsS0FBSztJQUNiLFFBQVEsRUFBRSxLQUFLO0lBQ2YsTUFBTSxFQUFFLEtBQUs7SUFDYixVQUFVLEVBQUUsS0FBSztDQUNsQixDQUFBO0FBRU0sTUFBTSxPQUFPLEdBQThCLEtBQUssRUFBRSxPQUFPLEVBQUUsQ0FBQyxFQUFFLE1BQU0sRUFBRSxFQUFFO0lBQzdFLE1BQU0sUUFBUSxHQUFHLElBQUksZUFBTSxDQUFDLFNBQVMsQ0FBQyxlQUFlLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFBO0lBQ3BFLE1BQU0sTUFBTSxHQUFHLElBQUksZUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsVUFBVSxFQUFFLFFBQVEsQ0FBQyxDQUFBO0lBRTdELE1BQU0sU0FBUyxHQUFHLElBQUksd0JBQVMsQ0FBQyxPQUFPLEVBQUUsWUFBWSxDQUFDLENBQUE7SUFDdEQsSUFBSSxTQUFTLENBQUMsS0FBSztRQUFFLE1BQU0sU0FBUyxDQUFDLEtBQUssQ0FBQTtJQUUxQyxNQUFNLFVBQVUsR0FBRyxZQUFZLENBQUE7SUFFL0IsTUFBTSxRQUFRLEdBQUcsU0FBUyxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUE7SUFDdkMsTUFBTSxlQUFlLEdBQUcsU0FBUyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFBO0lBQ3ZELE1BQU0sVUFBVSxHQUFHLFNBQVMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sSUFBSSxVQUFVLENBQUE7SUFDaEUsb0ZBQW9GO0lBQ3BGLE1BQU0sUUFBUSxHQUFHLFNBQVMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQTtJQUNsRCwyREFBMkQ7SUFDM0QsK0NBQStDO0lBQy9DLE1BQU0sVUFBVSxHQUFHLFNBQVMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sSUFBSSxTQUFTLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLElBQUksRUFBRSxDQUFBO0lBQy9GLGdEQUFnRDtJQUNoRCxJQUFJLGVBQWUsQ0FBQTtJQUNuQixJQUFJLFFBQVEsRUFBRTtRQUNaLGVBQWUsR0FBRyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsUUFBUSxFQUFFLFVBQVUsQ0FBQyxDQUFBO0tBQzdFO1NBQU07UUFDTCxlQUFlLEdBQUcsVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsVUFBVSxDQUFBO0tBQzNEO0lBRUQsTUFBTSxXQUFXLEdBQUc7UUFDbEIsRUFBRSxFQUFFLGVBQWU7UUFDbkIsSUFBSSxFQUFFLGVBQWU7S0FDdEIsQ0FBQTtJQUVELElBQUk7UUFDRixNQUFNLEVBQUUsR0FBRyxNQUFNLE1BQU0sQ0FBQyxlQUFlLENBQUMsV0FBVyxDQUFDLENBQUE7UUFDcEQsT0FBTyx3QkFBUyxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUU7WUFDakMsSUFBSSxFQUFFLEVBQUU7WUFDUixNQUFNLEVBQUUsR0FBRztTQUNaLENBQUMsQ0FBQTtLQUNIO0lBQUMsT0FBTyxDQUFDLEVBQUU7UUFDVixNQUFNLElBQUksMkJBQVksQ0FBQztZQUNyQixRQUFRO1lBQ1IsT0FBTyxFQUFFLENBQUM7WUFDVixVQUFVLEVBQUUsR0FBRztTQUNoQixDQUFDLENBQUE7S0FDSDtBQUNILENBQUMsQ0FBQTtBQTNDWSxRQUFBLE9BQU8sV0EyQ25CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmVxdWVzdGVyLCBWYWxpZGF0b3IsIEFkYXB0ZXJFcnJvciB9IGZyb20gJ0BjaGFpbmxpbmsvZWEtYm9vdHN0cmFwJ1xuaW1wb3J0IHsgRXhlY3V0ZVdpdGhDb25maWcgfSBmcm9tICdAY2hhaW5saW5rL3R5cGVzJ1xuaW1wb3J0IHsgZXRoZXJzIH0gZnJvbSAnZXRoZXJzJ1xuaW1wb3J0IHsgQ29uZmlnIH0gZnJvbSAnLi4vY29uZmlnJ1xuXG5leHBvcnQgY29uc3QgTkFNRSA9ICd0eHNlbmQnXG5cbmNvbnN0IGVuY29kZSA9ICh0eXBlOiBhbnksIHZhbHVlOiBhbnkpID0+IHtcbiAgbGV0IHJldFZhbFxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdieXRlczMyJzpcbiAgICAgIHJldFZhbCA9IGV0aGVycy51dGlscy5mb3JtYXRCeXRlczMyU3RyaW5nKHZhbHVlKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0VmFsID0gZXRoZXJzLnV0aWxzLmRlZmF1bHRBYmlDb2Rlci5lbmNvZGUoW3R5cGVdLCBbdmFsdWVdKVxuICAgICAgYnJlYWtcbiAgfVxuICByZXR1cm4gcmV0VmFsLnNsaWNlKDIpXG59XG5cbmNvbnN0IGN1c3RvbVBhcmFtcyA9IHtcbiAgZXhBZGRyOiB0cnVlLFxuICBmdW5jSWQ6IGZhbHNlLFxuICBkYXRhVHlwZTogZmFsc2UsXG4gIHJlc3VsdDogZmFsc2UsXG4gIGRhdGFUb1NlbmQ6IGZhbHNlLFxufVxuXG5leHBvcnQgY29uc3QgZXhlY3V0ZTogRXhlY3V0ZVdpdGhDb25maWc8Q29uZmlnPiA9IGFzeW5jIChyZXF1ZXN0LCBfLCBjb25maWcpID0+IHtcbiAgY29uc3QgcHJvdmlkZXIgPSBuZXcgZXRoZXJzLnByb3ZpZGVycy5Kc29uUnBjUHJvdmlkZXIoY29uZmlnLnJwY1VybClcbiAgY29uc3Qgd2FsbGV0ID0gbmV3IGV0aGVycy5XYWxsZXQoY29uZmlnLnByaXZhdGVLZXksIHByb3ZpZGVyKVxuXG4gIGNvbnN0IHZhbGlkYXRvciA9IG5ldyBWYWxpZGF0b3IocmVxdWVzdCwgY3VzdG9tUGFyYW1zKVxuICBpZiAodmFsaWRhdG9yLmVycm9yKSB0aHJvdyB2YWxpZGF0b3IuZXJyb3JcblxuICBjb25zdCBnZXRVaW50MjU2ID0gJzB4YzJiMTJhNzMnXG5cbiAgY29uc3Qgam9iUnVuSUQgPSB2YWxpZGF0b3IudmFsaWRhdGVkLmlkXG4gIGNvbnN0IGV4dGVybmFsQWRkcmVzcyA9IHZhbGlkYXRvci52YWxpZGF0ZWQuZGF0YS5leEFkZHJcbiAgY29uc3QgZnVuY3Rpb25JZCA9IHZhbGlkYXRvci52YWxpZGF0ZWQuZGF0YS5mdW5jSWQgfHwgZ2V0VWludDI1NlxuICAvLyBQYXNzaW5nIHRoaXMgb3B0aW9uYWxseSwgaW4gY2FzZSB0aGUgZGF0YSBpcyBub3QgZW5jcnlwdGVkIGZyb20gdGhlIHByZXZpb3VzIHN0ZXBcbiAgY29uc3QgZGF0YVR5cGUgPSB2YWxpZGF0b3IudmFsaWRhdGVkLmRhdGEuZGF0YVR5cGVcbiAgLy8gUHJpb3JpdGl6ZSBkYXRhIGNvbWluZyBmcm9tIGEgcHJldmlvdXMgYWRhcHRlciAocmVzdWx0KSxcbiAgLy8gYnV0IGFsbG93IGRhdGFUb1NlbmQgdG8gYmUgdXNlZCBpZiBzcGVjaWZpZWRcbiAgY29uc3QgZGF0YVRvU2VuZCA9IHZhbGlkYXRvci52YWxpZGF0ZWQuZGF0YS5yZXN1bHQgfHwgdmFsaWRhdG9yLnZhbGlkYXRlZC5kYXRhLmRhdGFUb1NlbmQgfHwgJydcbiAgLy8gRW5zdXJlIHdlIHVzZSBvbmx5IDQgYnl0ZXMgZm9yIHRoZSBmdW5jdGlvbklkXG4gIGxldCB0cmFuc2FjdGlvbkRhdGFcbiAgaWYgKGRhdGFUeXBlKSB7XG4gICAgdHJhbnNhY3Rpb25EYXRhID0gZnVuY3Rpb25JZC5zdWJzdHJpbmcoMCwgMTApICsgZW5jb2RlKGRhdGFUeXBlLCBkYXRhVG9TZW5kKVxuICB9IGVsc2Uge1xuICAgIHRyYW5zYWN0aW9uRGF0YSA9IGZ1bmN0aW9uSWQuc3Vic3RyaW5nKDAsIDEwKSArIGRhdGFUb1NlbmRcbiAgfVxuXG4gIGNvbnN0IHRyYW5zYWN0aW9uID0ge1xuICAgIHRvOiBleHRlcm5hbEFkZHJlc3MsXG4gICAgZGF0YTogdHJhbnNhY3Rpb25EYXRhLFxuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB0eCA9IGF3YWl0IHdhbGxldC5zZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pXG4gICAgcmV0dXJuIFJlcXVlc3Rlci5zdWNjZXNzKGpvYlJ1bklELCB7XG4gICAgICBkYXRhOiB0eCxcbiAgICAgIHN0YXR1czogMjAwLFxuICAgIH0pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgQWRhcHRlckVycm9yKHtcbiAgICAgIGpvYlJ1bklELFxuICAgICAgbWVzc2FnZTogZSxcbiAgICAgIHN0YXR1c0NvZGU6IDQwMCxcbiAgICB9KVxuICB9XG59XG4iXX0=