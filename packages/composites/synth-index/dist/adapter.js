"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeExecute = exports.execute = exports.getSynthIndexFor = exports.toFixedMax = void 0;
const tslib_1 = require("tslib");
const ea_bootstrap_1 = require("@chainlink/ea-bootstrap");
const ta = tslib_1.__importStar(require("@chainlink/token-allocation-adapter"));
const decimal_js_1 = tslib_1.__importDefault(require("decimal.js"));
const synthetix_1 = tslib_1.__importDefault(require("synthetix"));
const config_1 = require("./config");
const customParams = {
    base: ['base', 'asset', 'from'],
    network: false,
};
/**
 * Covert number to max number of decimals, trim trailing zeros
 *
 * @param num number to convert to fixed max number of decimals
 * @param decimals max number of decimals
 */
function toFixedMax(num, decimals) {
    return (new decimal_js_1.default(num)
        .toFixed(decimals)
        // remove trailing zeros
        .replace(/(\.\d*?[1-9])0+$/g, '$1')
        // remove decimal part if all zeros (or only decimal point)
        .replace(/\.0*$/g, ''));
}
exports.toFixedMax = toFixedMax;
function getAllocations(synth) {
    return synth.index.map((index) => {
        const decimals = 18;
        const balanceDec = new decimal_js_1.default(index.units).mul(10 ** decimals);
        const balance = toFixedMax(balanceDec, decimals);
        return { symbol: index.asset, balance, decimals };
    });
}
function isSynthIndex(synth) {
    return !!(synth && synth.index);
}
/**
 * Get a synth index token on a particular ethereum network
 *
 * @param network The ethereum network to use
 * @param base The name of the index token to fetch
 */
function getSynthIndexFor(network, base) {
    const synths = synthetix_1.default.getSynths({ network: network.toLowerCase() });
    const synth = synths
        .filter(({ index, inverted }) => index && !inverted)
        // executing a find here without checking if the array length is > 1 is fine here
        // since we know only one synth index token for a given name will exist per network
        .find((d) => d.name.toLowerCase() === base.toLowerCase());
    return isSynthIndex(synth) ? synth : undefined;
}
exports.getSynthIndexFor = getSynthIndexFor;
const execute = async (input, context, config) => {
    const validator = new ea_bootstrap_1.Validator(input, customParams);
    if (validator.error)
        throw validator.error;
    const { base, network = config.defaultNetwork } = validator.validated.data;
    const synthIndex = getSynthIndexFor(network, base);
    if (!synthIndex) {
        throw new ea_bootstrap_1.AdapterError({ message: `Index synth not found: ${base}`, statusCode: 400 });
    }
    const allocations = getAllocations(synthIndex);
    const _execute = ta.makeExecute(config.taConfig);
    return await _execute({ id: validator.validated.id, data: { ...input.data, allocations } }, context);
};
exports.execute = execute;
const makeExecute = (config) => {
    return async (request, context) => exports.execute(request, context, config || config_1.makeConfig());
};
exports.makeExecute = makeExecute;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWRhcHRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9hZGFwdGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSwwREFBaUU7QUFDakUsZ0ZBQXlEO0FBRXpELG9FQUFnQztBQUNoQyxrRUFBMkI7QUFFM0IscUNBQTZDO0FBRTdDLE1BQU0sWUFBWSxHQUFHO0lBQ25CLElBQUksRUFBRSxDQUFDLE1BQU0sRUFBRSxPQUFPLEVBQUUsTUFBTSxDQUFDO0lBQy9CLE9BQU8sRUFBRSxLQUFLO0NBQ2YsQ0FBQTtBQWNEOzs7OztHQUtHO0FBQ0gsU0FBZ0IsVUFBVSxDQUFDLEdBQWtCLEVBQUUsUUFBZ0I7SUFDN0QsT0FBTyxDQUNMLElBQUksb0JBQU8sQ0FBQyxHQUFHLENBQUM7U0FDYixPQUFPLENBQUMsUUFBUSxDQUFDO1FBQ2xCLHdCQUF3QjtTQUN2QixPQUFPLENBQUMsbUJBQW1CLEVBQUUsSUFBSSxDQUFDO1FBQ25DLDJEQUEyRDtTQUMxRCxPQUFPLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxDQUN6QixDQUFBO0FBQ0gsQ0FBQztBQVRELGdDQVNDO0FBRUQsU0FBUyxjQUFjLENBQUMsS0FBaUI7SUFDdkMsT0FBTyxLQUFLLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFO1FBQy9CLE1BQU0sUUFBUSxHQUFHLEVBQUUsQ0FBQTtRQUNuQixNQUFNLFVBQVUsR0FBRyxJQUFJLG9CQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLElBQUksUUFBUSxDQUFDLENBQUE7UUFDL0QsTUFBTSxPQUFPLEdBQUcsVUFBVSxDQUFDLFVBQVUsRUFBRSxRQUFRLENBQUMsQ0FBQTtRQUNoRCxPQUFPLEVBQUUsTUFBTSxFQUFFLEtBQUssQ0FBQyxLQUFLLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxDQUFBO0lBQ25ELENBQUMsQ0FBQyxDQUFBO0FBQ0osQ0FBQztBQUVELFNBQVMsWUFBWSxDQUFDLEtBQXdCO0lBQzVDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQTtBQUNqQyxDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFnQixnQkFBZ0IsQ0FBQyxPQUFlLEVBQUUsSUFBWTtJQUM1RCxNQUFNLE1BQU0sR0FBWSxtQkFBRyxDQUFDLFNBQVMsQ0FBQyxFQUFFLE9BQU8sRUFBRSxPQUFPLENBQUMsV0FBVyxFQUFFLEVBQUUsQ0FBQyxDQUFBO0lBQ3pFLE1BQU0sS0FBSyxHQUFHLE1BQU07U0FDakIsTUFBTSxDQUFDLENBQUMsRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLEVBQUUsRUFBRSxDQUFDLEtBQUssSUFBSSxDQUFDLFFBQVEsQ0FBQztRQUNwRCxpRkFBaUY7UUFDakYsbUZBQW1GO1NBQ2xGLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsS0FBSyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQTtJQUUzRCxPQUFPLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUE7QUFDaEQsQ0FBQztBQVRELDRDQVNDO0FBRU0sTUFBTSxPQUFPLEdBQThCLEtBQUssRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxFQUFFO0lBQ2pGLE1BQU0sU0FBUyxHQUFHLElBQUksd0JBQVMsQ0FBQyxLQUFLLEVBQUUsWUFBWSxDQUFDLENBQUE7SUFDcEQsSUFBSSxTQUFTLENBQUMsS0FBSztRQUFFLE1BQU0sU0FBUyxDQUFDLEtBQUssQ0FBQTtJQUUxQyxNQUFNLEVBQUUsSUFBSSxFQUFFLE9BQU8sR0FBRyxNQUFNLENBQUMsY0FBYyxFQUFFLEdBQUcsU0FBUyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUE7SUFDMUUsTUFBTSxVQUFVLEdBQUcsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFBO0lBQ2xELElBQUksQ0FBQyxVQUFVLEVBQUU7UUFDZixNQUFNLElBQUksMkJBQVksQ0FBQyxFQUFFLE9BQU8sRUFBRSwwQkFBMEIsSUFBSSxFQUFFLEVBQUUsVUFBVSxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUE7S0FDdkY7SUFFRCxNQUFNLFdBQVcsR0FBRyxjQUFjLENBQUMsVUFBVSxDQUFDLENBQUE7SUFDOUMsTUFBTSxRQUFRLEdBQUcsRUFBRSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUE7SUFDaEQsT0FBTyxNQUFNLFFBQVEsQ0FDbkIsRUFBRSxFQUFFLEVBQUUsU0FBUyxDQUFDLFNBQVMsQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFLEVBQUUsR0FBRyxLQUFLLENBQUMsSUFBSSxFQUFFLFdBQVcsRUFBRSxFQUFFLEVBQ3BFLE9BQU8sQ0FDUixDQUFBO0FBQ0gsQ0FBQyxDQUFBO0FBaEJZLFFBQUEsT0FBTyxXQWdCbkI7QUFFTSxNQUFNLFdBQVcsR0FBRyxDQUFDLE1BQWUsRUFBVyxFQUFFO0lBQ3RELE9BQU8sS0FBSyxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsRUFBRSxDQUFDLGVBQU8sQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sSUFBSSxtQkFBVSxFQUFFLENBQUMsQ0FBQTtBQUN0RixDQUFDLENBQUE7QUFGWSxRQUFBLFdBQVcsZUFFdkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBZGFwdGVyRXJyb3IsIFZhbGlkYXRvciB9IGZyb20gJ0BjaGFpbmxpbmsvZWEtYm9vdHN0cmFwJ1xuaW1wb3J0ICogYXMgdGEgZnJvbSAnQGNoYWlubGluay90b2tlbi1hbGxvY2F0aW9uLWFkYXB0ZXInXG5pbXBvcnQgeyBFeGVjdXRlLCBFeGVjdXRlV2l0aENvbmZpZyB9IGZyb20gJ0BjaGFpbmxpbmsvdHlwZXMnXG5pbXBvcnQgRGVjaW1hbCBmcm9tICdkZWNpbWFsLmpzJ1xuaW1wb3J0IHNueCBmcm9tICdzeW50aGV0aXgnXG5pbXBvcnQgeyBTZXRSZXF1aXJlZCB9IGZyb20gJ3R5cGUtZmVzdCdcbmltcG9ydCB7IENvbmZpZywgbWFrZUNvbmZpZyB9IGZyb20gJy4vY29uZmlnJ1xuXG5jb25zdCBjdXN0b21QYXJhbXMgPSB7XG4gIGJhc2U6IFsnYmFzZScsICdhc3NldCcsICdmcm9tJ10sXG4gIG5ldHdvcms6IGZhbHNlLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN5bnRoIHtcbiAgbmFtZTogc3RyaW5nXG4gIGFzc2V0Pzogc3RyaW5nXG4gIGluZGV4Pzoge1xuICAgIGFzc2V0OiBzdHJpbmdcbiAgICBjYXRlZ29yeTogc3RyaW5nXG4gICAgdW5pdHM6IG51bWJlclxuICB9W11cbiAgaW52ZXJ0ZWQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG59XG5cbmV4cG9ydCB0eXBlIFN5bnRoSW5kZXggPSBTZXRSZXF1aXJlZDxTeW50aCwgJ2luZGV4Jz5cbi8qKlxuICogQ292ZXJ0IG51bWJlciB0byBtYXggbnVtYmVyIG9mIGRlY2ltYWxzLCB0cmltIHRyYWlsaW5nIHplcm9zXG4gKlxuICogQHBhcmFtIG51bSBudW1iZXIgdG8gY29udmVydCB0byBmaXhlZCBtYXggbnVtYmVyIG9mIGRlY2ltYWxzXG4gKiBAcGFyYW0gZGVjaW1hbHMgbWF4IG51bWJlciBvZiBkZWNpbWFsc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdG9GaXhlZE1heChudW06IERlY2ltYWwuVmFsdWUsIGRlY2ltYWxzOiBudW1iZXIpOiBzdHJpbmcge1xuICByZXR1cm4gKFxuICAgIG5ldyBEZWNpbWFsKG51bSlcbiAgICAgIC50b0ZpeGVkKGRlY2ltYWxzKVxuICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHplcm9zXG4gICAgICAucmVwbGFjZSgvKFxcLlxcZCo/WzEtOV0pMCskL2csICckMScpXG4gICAgICAvLyByZW1vdmUgZGVjaW1hbCBwYXJ0IGlmIGFsbCB6ZXJvcyAob3Igb25seSBkZWNpbWFsIHBvaW50KVxuICAgICAgLnJlcGxhY2UoL1xcLjAqJC9nLCAnJylcbiAgKVxufVxuXG5mdW5jdGlvbiBnZXRBbGxvY2F0aW9ucyhzeW50aDogU3ludGhJbmRleCk6IHRhLnR5cGVzLlRva2VuQWxsb2NhdGlvbnMge1xuICByZXR1cm4gc3ludGguaW5kZXgubWFwKChpbmRleCkgPT4ge1xuICAgIGNvbnN0IGRlY2ltYWxzID0gMThcbiAgICBjb25zdCBiYWxhbmNlRGVjID0gbmV3IERlY2ltYWwoaW5kZXgudW5pdHMpLm11bCgxMCAqKiBkZWNpbWFscylcbiAgICBjb25zdCBiYWxhbmNlID0gdG9GaXhlZE1heChiYWxhbmNlRGVjLCBkZWNpbWFscylcbiAgICByZXR1cm4geyBzeW1ib2w6IGluZGV4LmFzc2V0LCBiYWxhbmNlLCBkZWNpbWFscyB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIGlzU3ludGhJbmRleChzeW50aDogU3ludGggfCB1bmRlZmluZWQpOiBzeW50aCBpcyBTeW50aEluZGV4IHtcbiAgcmV0dXJuICEhKHN5bnRoICYmIHN5bnRoLmluZGV4KVxufVxuXG4vKipcbiAqIEdldCBhIHN5bnRoIGluZGV4IHRva2VuIG9uIGEgcGFydGljdWxhciBldGhlcmV1bSBuZXR3b3JrXG4gKlxuICogQHBhcmFtIG5ldHdvcmsgVGhlIGV0aGVyZXVtIG5ldHdvcmsgdG8gdXNlXG4gKiBAcGFyYW0gYmFzZSBUaGUgbmFtZSBvZiB0aGUgaW5kZXggdG9rZW4gdG8gZmV0Y2hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFN5bnRoSW5kZXhGb3IobmV0d29yazogc3RyaW5nLCBiYXNlOiBzdHJpbmcpOiBTeW50aEluZGV4IHwgdW5kZWZpbmVkIHtcbiAgY29uc3Qgc3ludGhzOiBTeW50aFtdID0gc254LmdldFN5bnRocyh7IG5ldHdvcms6IG5ldHdvcmsudG9Mb3dlckNhc2UoKSB9KVxuICBjb25zdCBzeW50aCA9IHN5bnRoc1xuICAgIC5maWx0ZXIoKHsgaW5kZXgsIGludmVydGVkIH0pID0+IGluZGV4ICYmICFpbnZlcnRlZClcbiAgICAvLyBleGVjdXRpbmcgYSBmaW5kIGhlcmUgd2l0aG91dCBjaGVja2luZyBpZiB0aGUgYXJyYXkgbGVuZ3RoIGlzID4gMSBpcyBmaW5lIGhlcmVcbiAgICAvLyBzaW5jZSB3ZSBrbm93IG9ubHkgb25lIHN5bnRoIGluZGV4IHRva2VuIGZvciBhIGdpdmVuIG5hbWUgd2lsbCBleGlzdCBwZXIgbmV0d29ya1xuICAgIC5maW5kKChkKSA9PiBkLm5hbWUudG9Mb3dlckNhc2UoKSA9PT0gYmFzZS50b0xvd2VyQ2FzZSgpKVxuXG4gIHJldHVybiBpc1N5bnRoSW5kZXgoc3ludGgpID8gc3ludGggOiB1bmRlZmluZWRcbn1cblxuZXhwb3J0IGNvbnN0IGV4ZWN1dGU6IEV4ZWN1dGVXaXRoQ29uZmlnPENvbmZpZz4gPSBhc3luYyAoaW5wdXQsIGNvbnRleHQsIGNvbmZpZykgPT4ge1xuICBjb25zdCB2YWxpZGF0b3IgPSBuZXcgVmFsaWRhdG9yKGlucHV0LCBjdXN0b21QYXJhbXMpXG4gIGlmICh2YWxpZGF0b3IuZXJyb3IpIHRocm93IHZhbGlkYXRvci5lcnJvclxuXG4gIGNvbnN0IHsgYmFzZSwgbmV0d29yayA9IGNvbmZpZy5kZWZhdWx0TmV0d29yayB9ID0gdmFsaWRhdG9yLnZhbGlkYXRlZC5kYXRhXG4gIGNvbnN0IHN5bnRoSW5kZXggPSBnZXRTeW50aEluZGV4Rm9yKG5ldHdvcmssIGJhc2UpXG4gIGlmICghc3ludGhJbmRleCkge1xuICAgIHRocm93IG5ldyBBZGFwdGVyRXJyb3IoeyBtZXNzYWdlOiBgSW5kZXggc3ludGggbm90IGZvdW5kOiAke2Jhc2V9YCwgc3RhdHVzQ29kZTogNDAwIH0pXG4gIH1cblxuICBjb25zdCBhbGxvY2F0aW9ucyA9IGdldEFsbG9jYXRpb25zKHN5bnRoSW5kZXgpXG4gIGNvbnN0IF9leGVjdXRlID0gdGEubWFrZUV4ZWN1dGUoY29uZmlnLnRhQ29uZmlnKVxuICByZXR1cm4gYXdhaXQgX2V4ZWN1dGUoXG4gICAgeyBpZDogdmFsaWRhdG9yLnZhbGlkYXRlZC5pZCwgZGF0YTogeyAuLi5pbnB1dC5kYXRhLCBhbGxvY2F0aW9ucyB9IH0sXG4gICAgY29udGV4dCxcbiAgKVxufVxuXG5leHBvcnQgY29uc3QgbWFrZUV4ZWN1dGUgPSAoY29uZmlnPzogQ29uZmlnKTogRXhlY3V0ZSA9PiB7XG4gIHJldHVybiBhc3luYyAocmVxdWVzdCwgY29udGV4dCkgPT4gZXhlY3V0ZShyZXF1ZXN0LCBjb250ZXh0LCBjb25maWcgfHwgbWFrZUNvbmZpZygpKVxufVxuIl19